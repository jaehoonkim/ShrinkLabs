<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code on ShrinkLabs</title>
    <link>https://shrinklabs.com/categories/code/</link>
    <description>Recent content in code on ShrinkLabs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 21 Aug 2018 16:34:04 +0900</lastBuildDate>
    
	<atom:link href="https://shrinklabs.com/categories/code/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>cscope 사용(Go)</title>
      <link>https://shrinklabs.com/posts/cscope/</link>
      <pubDate>Tue, 21 Aug 2018 16:34:04 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/cscope/</guid>
      <description>Go언어 개발 환경(추가) Go언어로 작성한 코드를 분석하기 위해서 cscope가 필요할 때가 있다.
vim에서 cscope를 사용하기 위한 과정을 정리해 보려고 한다.
cscope를 설치한다. $ sudo apt-get install cscope  mkscope.sh 파일을 만든다. mkscope.sh의 내용은 다음과 같다.
이 스크립트는 https://www.cnblogs.com/shaohef/p/7358111.html 의 내용을 수정해서 사용했다.
#!/bin/bash # 기존에 존재하던 files와 out 파일을 제거한다 rm cscope.files cscope.out # $GOROOT가 존재하지 않으면 설정한다. if [&amp;quot;$GOROOT&amp;quot; = &amp;quot;&amp;quot;]; then echo &amp;quot;GOROOT is not set&amp;quot; GOROOT=`go env | grep &amp;quot;GOROOT&amp;quot; | cut -d &amp;quot;=&amp;quot; -f2` GOROOT=${GOROOT#\&amp;quot;} GOROOT=${GOROOT%\&amp;quot;} fi echo $GOROOT # Go 표준 패키지 go_src=$GOROOT/src # Go언어 표준 패키지로 제공되는 go 파일의 경로를 cscope.</description>
    </item>
    
    <item>
      <title>map에 key가 존재하는지 확인</title>
      <link>https://shrinklabs.com/posts/key_exists_in_map/</link>
      <pubDate>Thu, 12 Jul 2018 16:52:08 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/key_exists_in_map/</guid>
      <description>map을 사용할때 해당하는 키가 map에 존재하는지 확인이 필요할 때가 있다.
var target[string]*item ... target[&amp;quot;apple&amp;quot;] = itm1 target[&amp;quot;orange&amp;quot;] = itm2 ... value, ok := target[&amp;quot;kiwi&amp;quot;]  </description>
    </item>
    
    <item>
      <title>Go언어 프로젝트에서 테스트 코드 작성 경험</title>
      <link>https://shrinklabs.com/posts/writing-a-unit-test/</link>
      <pubDate>Wed, 21 Feb 2018 23:02:29 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/writing-a-unit-test/</guid>
      <description>주의, 아래의 내용은 학습을 하면서 이해한 정도에서의 정리라서 틀린 내용이 많이 있을 수 있습니다. 이제 테스트 코드 작성을 시도해보기 시작하는 뉴비라서… 잘못된 부분은 지적을 해주시면 감사한 마음으로 배우겠습니다.
테스트 코드는 왜? 현재 프로젝트를 진행 중 코딩을 할 때면 계속해서 의심과 두려움이 들었다.
&amp;ldquo;내가 제대로 작성하고 있는 게 맞나?&amp;rdquo;
&amp;ldquo;이렇게 작성하면 다른 데에서 문제가 생기는 건 아닌가?&amp;rdquo;
그리고 이런 걱정들은 다음의 2가지 원인 때문이지 않을까 라고 생각하게 되었다.
첫 번째, 코드 작성 후 실행해서 결과를 확인하기 위해서 개인 개발 환경을 MessageQueue와 내가 보낸 요청에 대해 기대하는 응답을 전달해줄 MessageQueue 반대편의 모듈을 구성하기가 쉽지 않다는 것이었다.</description>
    </item>
    
    <item>
      <title>core파일 만들기</title>
      <link>https://shrinklabs.com/posts/core/</link>
      <pubDate>Tue, 01 Aug 2017 13:59:57 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/core/</guid>
      <description>Go언어에서도 core dump를 떨구는 방법이 있었다.
데이브체니님이 정리해 놓은 무려 2015년도의 글이다.
https://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables
환경변수로 GOTRACEBACK 을 crash로 설정만 해주면 된다.
이런것도 모르고 Go언어에서는 dump를 생성할 수 없다고 말하고 다녔다&amp;hellip;;
근데 위에 처럼 환경변수 설정하고도 core 파일이 안생긴다면, 다음 블로그의 글을 참고해 보면 좋을것 같다.
http://lapan.tistory.com/68
블로그의 내용처럼 ulimit -a 로 확인 해보니 core file size가 0으로 되어 있다.
ulimit -c unlimited 로 해주었다.
이제 panic을 발생시켜 보면 core 파일이 잘 만들어져 있는걸 확인 할 수 있다.</description>
    </item>
    
    <item>
      <title>delve를 사용한 Go언어 디버깅</title>
      <link>https://shrinklabs.com/posts/delve/</link>
      <pubDate>Sun, 18 Jun 2017 23:13:14 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/delve/</guid>
      <description>소개 delve는 Go언어를 위한 debugger 이다.
delve설치 설치를 하기위해서는 Go 1.5 이상의 버전이 필요하다.
지금 시점에 Go 1.5를 사용하지 않을테니&amp;hellip;
다음의 명령으로 설치한다.
$ go get github.com/derekparker/delve/cmd/dlv  이제 설치 끝! (Windows랑 MAC은 모르겠다.)
delve사용 프로세스 실행 제어, 변수, 스레드/goroutine 상태, CPU 레지스터 상태 등을 확인 할 수 있다.
 Commands
 attach: 실행중인 프로세스에 연결해서 디버깅을 한다.
$ dlv attach pid [executable]  실행중인 프로세스에 디버그 세션을 연결해서 프로세스를 제어한다.</description>
    </item>
    
    <item>
      <title>build</title>
      <link>https://shrinklabs.com/posts/build/</link>
      <pubDate>Thu, 25 May 2017 15:43:40 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/build/</guid>
      <description>소개 Go언어로 개발을 하다보면 debug모드 release모드 같이 별도의 빌드 환경을 구성하고 싶을때가 있다.
그래서 build 옵션으로 특정한 환경별로 결과를 달리 할 수 있는 방법에 대해서 테스트한 내용을 정리해본다.
빌드 go 파일들을 빌드하기 위해서는 일반적으로 다음과 같이 한다.
$ go build  Go언어 문서중에 보면 https://golang.org/pkg/go/build/#hdr-Build_Constraints[Build Constraints] 에 관한 내용이 있다.
이 내용은 build 할 때 조건을 줄 수 있다는 내용이고 방법은 다음과 같이 하면 된다고 한다.
코드의 상단에 &amp;ldquo;// +build linux&amp;rdquo; 하고 한 칸을 띄우고 &amp;ldquo;package blah&amp;rdquo; 를 시작한다.</description>
    </item>
    
    <item>
      <title>CreateFormFile()을 사용하면 Content-Type이 고정되는 현상</title>
      <link>https://shrinklabs.com/posts/multipart-contenttype/</link>
      <pubDate>Sat, 10 Dec 2016 18:22:48 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/multipart-contenttype/</guid>
      <description>mime/multipart를 사용해서 파일을 업로드 하려 할때 파일을 업로드할 필드를 생성하기 위해서 CreateFormFile()을 사용한다.
이를 이용해서 파일을 업로드하면 &amp;ldquo;Content-Type&amp;rdquo;이 &amp;ldquo;application/octet-stream&amp;rdquo; 으로 고정되어진다.
src/mime/multipart/writer.go의 CreateFormFile을 확인해 보면 다음과 같이 고정되어 있는걸 확인 할 수 있다.
h.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/octet-stream&amp;quot;)  관련한 이슈가 올라온게 혹시 있지 않을까 해서 찾아보니.
이런 이슈가 있었다.
https://github.com/golang/go/issues/16425
bradfitz는 다음과 같이 답변을 하고 있다.
 Use CreatePart. CreateFormFile is a very thin wrapper around CreatePart. Click https://golang.org/pkg/mime/multipart/#Writer.CreateFormField[] and then click the CreateFormFile heading to see its source code.</description>
    </item>
    
    <item>
      <title>Go코드로 HTML Form 전송</title>
      <link>https://shrinklabs.com/posts/html-form/</link>
      <pubDate>Tue, 06 Dec 2016 01:13:41 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/html-form/</guid>
      <description>HTML, Javascript를 사용해서 Post방식으로 Form을 전송하는 동작을 Go 코드를 작성해 보자.
우선 POST로 전송된 Form을 받아서 처리를 하는 서버쪽을 다음과 같은 구성을 갖는 코드로 만든다.
package main import { &amp;quot;net/http&amp;quot; &amp;quot;github.com/gorilla/mux&amp;quot; } func main() { r := mux.Newrouter().StrictSlash(false) r.HandleFunc(&amp;quot;/upload&amp;quot;, upload).Methods(&amp;quot;POST&amp;quot;) http.ListenAndServe(&amp;quot;:8080&amp;quot;, r) } func upload(w http.ResponseWriter, r *http.Request) { if r.Method == &amp;quot;POST&amp;quot; { } }  이렇게 &amp;ldquo;http://localhost:8080/upload&amp;quot; 를 통해서 POST 방식으로 전달되는 요청을 받아서 처리하기 위한 큰틀을 만들었다.</description>
    </item>
    
    <item>
      <title>인코딩된 텍스트 디코딩하기</title>
      <link>https://shrinklabs.com/posts/encode-go/</link>
      <pubDate>Fri, 25 Nov 2016 00:52:47 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/encode-go/</guid>
      <description>Javascript에서 encodeURIComponent() 함수를 사용해서 전달받은 문자열을 디코딩해서 보기 위해서는 &amp;ldquo;net/url&amp;rdquo; 패키지의 QueryUnescape() 함수를 사용할 수 있다.
email, err := url.QueryUnescape(user.Email)  </description>
    </item>
    
    <item>
      <title>vendor 관리</title>
      <link>https://shrinklabs.com/posts/govendor/</link>
      <pubDate>Fri, 14 Oct 2016 18:16:35 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/govendor/</guid>
      <description>vendoring되어 있는 패키지를 관리해야 할 이유가 무엇인지에 대해서 찾아보다가 좋은 글을 발견했다.
https://gocodecloud.com/blog/2016/03/29/go-vendoring-beginner-tutorial/
이 글을 읽고 이해한 정도만을 요약
vendoring을 왜 하나? Project A에서 사용하는 Pkg X의 리비전 1을 사용하고 있다. 그런데 Project B에서는 Pkg X의 리비전 2를 사용하려 한다.
그런데 $GOPATH 안에는 같은 패키지를 하나만 갖고 있을 수 있다.
Pkg X의 리비전을 Project A에 맞추면 Project B가 빌드를 실패하고, Project B에 맞추면 Project A가 빌드에 실패하게 된다.
그래서 패키지들을 vendor 아래에 위치 시킨다.</description>
    </item>
    
    <item>
      <title>vim-go 기본 템플릿 비활성화</title>
      <link>https://shrinklabs.com/posts/vim-go/</link>
      <pubDate>Mon, 05 Sep 2016 01:28:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/vim-go/</guid>
      <description>vim-go가 언제부터인가 main.go 를 만들면 템플릿으로 fmt.Println(&amp;ldquo;vim-go&amp;rdquo;) 를 찍어주는 코드를 자동으로 생성해 주기 시작했다.
나는 아무것도 나오지 않기를 바랬는데, 이런게 나와서 매번 지우는 작업을 하는게 싫었다. 그래서 설정중에 go_template_autocreate 를 조절했다.
let g:go_template_autocreate = 0  와 같이 하면 이제 아무것도 없는 빈 화면이 나온다.
혹시라도 반복적으로 나오는게 좋은데 &amp;ldquo;vim-go&amp;rdquo;를 찍는게 아닌 특정한 코드가 필요하다면, &amp;ldquo;.vim/bundle/vim-go/templates/hello_world.go&amp;rdquo; 파일을 수정해도 된다. 또는 특정한 템플릿을 지정하고 싶다면, 다음과 같이,
let g:go_template_file = &amp;quot;hello_world.go&amp;quot;  로 해도 된다.</description>
    </item>
    
    <item>
      <title>template을 생성할때 왜 이름을 지정할까?</title>
      <link>https://shrinklabs.com/posts/template/</link>
      <pubDate>Sat, 03 Sep 2016 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/template/</guid>
      <description>Go언어의 Template 엔진을 사용할때, 왜 New()의 파라미터로 이름을 만들어서 넘겨야 하는지가 궁금했었다.
Template and Associated templates라는 글을 읽고 어느 정도 이해를 하게 되었다.
다음은 위 글의 내용을 요약한 것이다.
template.New() 로 template을 만들때, 이름을 정해서 만든다.
이 때 FuncMap과 템플릿 리스트를 갖는 그룹(그룹의 이 글에서 사용하는 용어로 Associated Templates를 가르킨다)이 생성된다.
FuncMap에 대해서는,
https://golang.org/pkg/html/template/#FuncMap
http://goinbigdata.com/example-of-using-templates-in-golang/
http://technosophos.com/2013/11/23/using-custom-template-functions-in-go.html
를 확인해본다.
New()를 했어도 아직 템플릿 리스트에서 관리되는 대상은 아니다.
Parse(&amp;hellip;)를 하면 템플릿 리스트에 추가가 된다.</description>
    </item>
    
    <item>
      <title>css와 같은 정적 컨텐츠를 html에서 사용하기 위한 팁</title>
      <link>https://shrinklabs.com/posts/css-html/</link>
      <pubDate>Mon, 18 Jul 2016 10:16:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/css-html/</guid>
      <description>Go의 &amp;ldquo;net/http&amp;rdquo;와 &amp;ldquo;html/template&amp;rdquo;를 이용해서 html과 css로 만들어진 웹페이지를 만들려고 할때, html 파일이 보여질때 css가 적용되지 않은 상태로 보여진다.
이 때 어떻게 해야 하는지 방법을 찾아가던 과정을 기록으로 남겨 놓는다.
프로젝트의 디렉토리 구조는 다음과 같다.
src\ + prj + main.go + static style.css + template index.html  그래서 이렇게&amp;hellip;
func main() { http.HandleFunc(&amp;quot;/&amp;quot;, indexHandler) http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil) } func indexHandler(...) { // index.html }  와 같이 하면 될 줄 알았다.
그런데 안된다.</description>
    </item>
    
    <item>
      <title>http 패키지의 HandleFunc과 Handle</title>
      <link>https://shrinklabs.com/posts/http-handlefunc-handle/</link>
      <pubDate>Sun, 17 Jul 2016 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/http-handlefunc-handle/</guid>
      <description>HandleFunc  http.ResponseWriter 와 *http.Request를 인자로 받는 함수를 전달받는다. 내부적으로 ServeHTTP가 구현된 ServeMux를 사용한다.
package main import ( &amp;quot;net/http&amp;quot; ) func indexHandler(w http.ResponseWriter, r *http.Request) { .... } func main() { http.HandleFunc(&amp;quot;/&amp;quot;, indexHandler) http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil) }   Handle  http.Handler 인터페이스를 구현한 객체를 전달받는다. 인자로 전달받은 객체는 http.Handler의 ServeHTTP(http.ResponseWriter, *http.Request)가 구현되어 있어야 한다.
package main import ( &amp;quot;net/http&amp;quot; ) type indexHandler struct { } func (index *AppHandler) ServeHTTP(w http.</description>
    </item>
    
    <item>
      <title>vendor 사용 팁(내부 패키지)</title>
      <link>https://shrinklabs.com/posts/vendor/</link>
      <pubDate>Wed, 09 Mar 2016 14:12:58 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/vendor/</guid>
      <description>프로젝트 내부에서 별도의 패키지를 만들어서 사용을 하려고 할때면,
import 경로를 &amp;ldquo;github.com/blah/project/internalpkg&amp;rdquo; 처럼 다 써야 했었다.
이제 vendor를 사용하면 pkg 이름만 import 해서 사용할 수 있게 되었다.
샘플 프로젝트는 다음과 같다.
https://github.com/sabzil/lotto
샘플 프로젝트에 대해서 약간의 설명을 더하면,
기존에는 command 패키지를 commands.go 에서 import 하기 위해서,
import &amp;ldquo;github.com/sabzil/lotto/command&amp;rdquo; 와 같이 사용해야 했었다.
이렇게 되면 lotto 프로젝트를 다른 사람이 fork 해서 사용하려고 하면 일일이 import 경로를 변경해줘야 하는 문제가 생기게 된다.
그래서 go1.</description>
    </item>
    
    <item>
      <title>pkg 원격저장소 연결하기</title>
      <link>https://shrinklabs.com/posts/meta-tag-pkg-repository/</link>
      <pubDate>Thu, 11 Jun 2015 13:43:41 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/meta-tag-pkg-repository/</guid>
      <description>최근에 go소스들을 분석하면서 특이한 pkg import 경로들을 보게되었다.
import &amp;quot;rsc.io/pdf&amp;quot;  와 같은 &amp;ldquo;github.com/rsc/pdf&amp;rdquo; 와 동일한 내용인데 그리고 rsc는 russ cox가 사용하는 닉네임인데&amp;hellip;그럼 같은 pkg인가?
그래서 웹브라우저에서 rsc.io/pdf 를 입력하면 godoc로 이동을 하네?
어떻게 한걸까!? 궁금했다. 그리고 왠지 멋있어 보였다&amp;hellip;;
그러다가 우연히 rob pike의 github page(https://github.com/robpike/robpike.github.io)를 보게 되었다.
index.html 에 이렇게만 코드가 되어 있었다.
&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;robpike.io/cmd hg https://code.google.com/p/rspace.cmd&amp;quot;&amp;gt; This is a git repository holding a redirect for the Go repositories referenced by robpike.</description>
    </item>
    
    <item>
      <title>pkg-config 사용</title>
      <link>https://shrinklabs.com/posts/pkg-config/</link>
      <pubDate>Fri, 06 Mar 2015 01:28:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/pkg-config/</guid>
      <description>Go언어를 사용하다보면 C로 만들어진 라이브러리를 사용하기 위해서 cgo가 필요할 때 가 있다. 라이브러리를 링크하고 하는 몇 가지 절차를 거치게 되는데, 이때 pkg-config라는걸 사용하면 편리하다.
pkg-config를 사용하면 컴파일하는데 필요한 라이브러리와 헤더정보를 Go코드상에서 동일한 경로로 제공해줄 수 있게 된다.
pkg-config가 설치되어 있지 않을 경우에는 다음과 같이 설치를 해준다.
$ sudo apt-get install pkg-config  이제 설치되어 있는 라이브러리 목록을 한번 보자.
$ pkg-config --list-all  현재 설치된 라이브러리들의 정보가 나오게 된다.
그런데 내가 원하는 라이브러리의 정보가 나타나지 않는다.</description>
    </item>
    
    <item>
      <title>Golang channels tutorial</title>
      <link>https://shrinklabs.com/posts/golang-channels-tutorial/</link>
      <pubDate>Wed, 10 Dec 2014 13:12:58 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/golang-channels-tutorial/</guid>
      <description>최근에 goroutine과 channel에 대해서 학습하다가 설명이 잘 되어 있는 글을 찾아서 번역(이라고 하기에는 뭐하고 정리?) 를 해봤다. 제대로 이해를 못하고 잘 못 번역을 한 부분이 있을 수 도 있으니&amp;hellip;꼭 원본을 보길 권장한다.;;;
원본 : http://guzalexander.com/2013/12/06/golang-channels-tutorial.html
Go언어는 병렬 프로그램 작성을 위해서 내장 도구를 갖고 있다. go를 함수 호출 앞에 놓으면 동일한 주소에 위치하는 코드를 독립적인 병렬 스레드로 실행을 시작한다. 이런 쓰레드를 Go언어에서는 goroutine이라고 부른다. 여기에서 말하는 concurrently는 parallel을 의미하지는 않는다. (역주: 그렇지만 번역은 “병렬” 이라고 칭하겠다.</description>
    </item>
    
    <item>
      <title>md5 패키지 사용예</title>
      <link>https://shrinklabs.com/posts/md5/</link>
      <pubDate>Tue, 08 Oct 2013 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/md5/</guid>
      <description>Qt로 만드는 클라이언트에서 이미지 파일에 대해서 만들어진 md5 hash를 검증 해보기 위해서, 같은 이미지 파일에 대해서 Go언어로 md5 hash를 만들었을때 동일한 값이 생성되면 제대로 만들어진거 아닐까 해서, 만들어 봄.
(사실은 일하기 싫어서 괜히 한번 해 본&amp;hellip;)
package main import ( &amp;quot;io/ioutil&amp;quot; &amp;quot;crypto/md5&amp;quot; &amp;quot;fmt&amp;quot; ) func main() { data, err := ioutil.ReadFile(&amp;quot;1.jpg&amp;quot;) if err != nil { return; } hash := md5.New() hash.Write(data) hashData := hash.Sum(nil) fmt.Printf(&amp;quot;%x&amp;quot;, hashData) }  </description>
    </item>
    
    <item>
      <title>C언어의 배열을 Go언어의 slices로 변환</title>
      <link>https://shrinklabs.com/posts/c-go-slices/</link>
      <pubDate>Tue, 17 Sep 2013 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/c-go-slices/</guid>
      <description>cgo를 이용하다보면, C언어로 작성된 라이브러리의 리턴값으로 포인터에 구조체가 할당되어서 넘어올때가 있다.
C언어에서 넘어오는 구조체 배열이 포인터 형태로 넘어오니, Go의 포인터에 할당을 해서 사용 해봤다.
당연히 제대로 동작하지 않는다. C언어로 작성된 라이브러리에서 넘어오는 값은 배열이니, Go언어에서는 slices에 할당을 하는게 맞는것 같다.
다음의 내용을 보면, array를 어떻게 slices에 할당을 해야 할지에 대해서 잘 설명이 되어 있다.
&amp;ldquo;Turning C arrays into Go slcies&amp;rdquo; ( https://code.google.com/p/go-wiki/wiki/cgo )
아래는 cubrid driver를 만들면서 사용한 코드이다.
slcieHeader := (*reflect.</description>
    </item>
    
    <item>
      <title>type으로 이름 붙여진 구조체의 필드를 사용하기위한 방법</title>
      <link>https://shrinklabs.com/posts/cgo-type/</link>
      <pubDate>Tue, 03 Sep 2013 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/cgo-type/</guid>
      <description>c로 만들어져 있던 라이브러리를 cgo를 이용해서 포팅(?)을 하는 작업을 하다보면 난감한 부분들이 종종 나타난다.
그중에 한가지가 c에서 사용하던 구조체의 파라미터명이 go 에서 미리정의된 명칭일 경우가 있다.
대표적인 예로 &amp;ldquo;type&amp;rdquo;이라는 파라미터명이다.
c에서는 T_CCI_COL_INFO(cubrid의 cci에서 사용되는 구조체중에 하나) 의 필드중에 하나가 type이라는 필드가 하나 있다.
이걸 go에서 사용을 하려고 하니,,,
&amp;rdquo;&amp;hellip;expected selector or type assertion, found &amp;lsquo;type&amp;rsquo; &amp;ldquo; 이라는 결과를 만나게 된다.
이걸 도대체 어떻게 사용해야 하나 고민을 하던중, golang.org 에 있는 문서 http://golang.</description>
    </item>
    
    <item>
      <title>패키지 만들때 testing 패키지 사용하기</title>
      <link>https://shrinklabs.com/posts/testing/</link>
      <pubDate>Fri, 23 Aug 2013 14:12:58 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/testing/</guid>
      <description>개요 Go 언어용 패키지를 만들려면, 테스트코드를 해야 개발이 진행이 좀 더 원활하게 되는 것 같다.
그래서 간단하게 테스트 코드 작성하는 방법을 정리해봤다.
abc 패키지를 만들어서 테스트하기 src\abc\abc.go
src\abc\abc_test.go 와 같이 파일을 만들어 놓는다.
abc.go를 다음과 같이 작성한다.
// abc.go package abc import ( &amp;quot;fmt&amp;quot; ) func A_Method() { fmt.Println(&amp;quot;test A Method&amp;quot;) }  그리고 abc_test.go를 다음과 같이 작성한다.
// abc_test.go package abc import ( &amp;quot;testing&amp;quot; ) func TestA_Method(t *testing.T) { A_Method() }  그리고 $GOPATH/src/abc/ 에서</description>
    </item>
    
  </channel>
</rss>