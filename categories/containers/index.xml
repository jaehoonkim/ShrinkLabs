<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>containers on ShrinkLabs</title>
    <link>https://shrinklabs.com/categories/containers/</link>
    <description>Recent content in containers on ShrinkLabs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 05 Mar 2020 21:36:13 +0900</lastBuildDate>
    
	<atom:link href="https://shrinklabs.com/categories/containers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GCE에서 kops를 이용한 K8s 구성</title>
      <link>https://shrinklabs.com/posts/k8s-with-kops-on-gce/</link>
      <pubDate>Thu, 05 Mar 2020 21:36:13 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/k8s-with-kops-on-gce/</guid>
      <description>클러스터 배포용 VM 인스턴스 생성  Kubernetes를 구성하기 위한 VM 인스턴스를 생성한다.
 &amp;ldquo;ID 및 API 액세스&amp;rdquo; 항목에서 액세스 범위를 &amp;ldquo;모든 Cloud API에 대한 전체 액세스 허용&amp;rdquo; 으로 선택한다. 또는 아래와 같이 서비스 계정에 권한을 설정하고 서비스 계정을 선택해도 된다.
 GCP 관리 콘솔의 IAM&amp;amp;Admin에서 서비스 계정을 하나 만든다. 서비스 계정이 갖고 있어야 하는 최소한의 권한은 다음과 같다.
compute admin servce account admin service account key admin service account token creator service acount user storage admin DNS Administrator DNS Reader  SSH로 연결 &amp;amp; 업데이트</description>
    </item>
    
    <item>
      <title>docker image 저장소 위치 변경</title>
      <link>https://shrinklabs.com/posts/docker-image/</link>
      <pubDate>Thu, 05 Mar 2020 12:05:00 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/docker-image/</guid>
      <description> 새로운 디스크를 추가한다.
 여기에서는 &amp;ldquo;/docker&amp;rdquo; 에 mount 되어 있는걸로 가정한다.
  &amp;ldquo;etc/docker/daemon.json&amp;rdquo; 에 다음의 내용을 추가한다.
{ &amp;quot;data-root&amp;quot;: &amp;quot;/docker&amp;quot; }  docker 서비스를 재시작한다.
$ sudo systemctl daemon-reload $ sudo systemctl restart docker   </description>
    </item>
    
    <item>
      <title>10.Nginx Ingress Controller on Google Kubernetes Engine</title>
      <link>https://shrinklabs.com/posts/nginx-ingress-controller-on-google-kubernetes-engine/</link>
      <pubDate>Mon, 21 Jan 2019 17:05:30 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/nginx-ingress-controller-on-google-kubernetes-engine/</guid>
      <description>이번 과정에서는 &amp;ldquo;Ingress&amp;rdquo;에 대해서 알아 볼 수 있었다.
&amp;ldquo;Ingress&amp;rdquo;는 resource와 controller로 구성되어 있다.
resource는 &amp;ldquo;Ingress&amp;rdquo;의 동작에 대한 규칙을 정해 놓은 yaml이며,
controller는 layer7에 해당하는 로드밸런서의 역할을 제공한다. 즉 http 요청에 대한 처리와 부하 분산을 제공한다.
controller로는 gce, nginx, envoy, haproxy, istio, kong, traefik 을 이용할 수 있다.
과정에서는 &amp;ldquo;hello-app&amp;rdquo; 이라는 &amp;ldquo;Service&amp;rdquo;를 노출한다. 그리고 helm을 이용해서 nginx-ingress를 kubernetes cluster에 설치한다.
kind가 &amp;ldquo;Ingress&amp;rdquo;인 yaml 파일을 만든다. 이때 &amp;ldquo;path: /hello&amp;rdquo;로 지정하며, backend를 &amp;ldquo;serviceName: hello-app&amp;rdquo;과 &amp;ldquo;servicePort: 8080&amp;rdquo; 으로 지정을 한다.</description>
    </item>
    
    <item>
      <title>9.Helm Package Management</title>
      <link>https://shrinklabs.com/posts/helm-package-management/</link>
      <pubDate>Thu, 17 Jan 2019 15:04:00 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/helm-package-management/</guid>
      <description>이번 과정은 kubernetes에서 사용할 수 있는 패키지 관리자에 대해서 알아 볼 수 있었다.
Helm은 클라이언트 역할을 하는 helm, 서버 역할을 하는 tiller 그리고 설정 정보들의 관리를 위한 chart로 이루어져 있다.
여기에서 클라이언트(helm)라고 하는건 클러스터의 외부에서 작업을 지시하기 위한 도구이고, 실제로 클러스터 안쪽에서 동작 하는건 서버(tiller)라고 보면 된다.
helm의 설치는 간단합니다.
$ curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get &amp;gt; get_helm.sh $ chmod 700 get_helm.sh $ ./get_helm.sh  근데 이 과정 다음에 갑자기 tiller를 위한 계정을 만들고 해당 계정을 무언가에 바인딩을 한다.</description>
    </item>
    
    <item>
      <title>8.Setting Up a Private Kubernetes Cluster</title>
      <link>https://shrinklabs.com/posts/setting-up-private-kubernetes-cluster/</link>
      <pubDate>Wed, 16 Jan 2019 01:46:28 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/setting-up-private-kubernetes-cluster/</guid>
      <description>이번 과정의 실습을 진행하면서 클러스터에 대한 접근을 제한 할 수 있도록 하기 위한 방법에 대해서 알 수 있었다. 하지만 전체 내용에 대해서 정확하게 이해를 하지 못했다.
해당 내용은 이후에 비공개 클러스터 설정(https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters) 에 대한 내용이 실습 내용과 동일하므로 추후에 이해가 가능한 시점이 되면 다시 한번 시도해 보려고 한다.
아래는 내용을 이해하기 위해서 학습했던 내용들의 링크이다.
 네트워크 입문: http://kujung.tistory.com/category/%EB%98%A5%20%EC%8B%B8%EA%B8%B0/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC
 IPv4 네트워크 주소와 호스트 주소/서브넷팅/IP Class: http://itsaessak.tistory.com/174
 IP 주소체계와 클래스 구별법 (IPV4): http://korean-daeddo.</description>
    </item>
    
    <item>
      <title>7.Build Slack Bot With Node.js on Kubernetes</title>
      <link>https://shrinklabs.com/posts/build-slack-bot-with-nodejs-on-kubernetes/</link>
      <pubDate>Mon, 14 Jan 2019 13:17:21 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/build-slack-bot-with-nodejs-on-kubernetes/</guid>
      <description>이번 과정은 Secret 객체에 대해서 좀 더 자세하게 알아볼 수 있는 과정이었다.
서비스를 제공하는 프로그램(node.js 코드)을 Docker image로 만든 다음 Registry Server에 Push를 한다.
제공하는 서비스에서 외부의 서비스(slack)를 사용하기 위해서 민감한 정보인 token이 존재한다. 이 내용이 코드상 또는 image 상에 존재하지 않게 Image를 만들고자 한다.
그래서 별도로 &amp;ldquo;slack-token&amp;rdquo; 파일을 만들어서 파일을 통해서 token 정보를 제공하도록 만들어 놓았다. 해당 파일을 경로와 파일명을 포함해서 환경변수 &amp;ldquo;slack_token_path&amp;rdquo;에 등록해 놓고, 코드상에서는 환경 변수인 &amp;ldquo;slack_token_path&amp;rdquo;에 지정되어 있는 경로의 파일로 부터 token 정보를 읽어서 사용한다.</description>
    </item>
    
    <item>
      <title>6.Running Mongodb Database in Kubernetes With Statefulsets</title>
      <link>https://shrinklabs.com/posts/running-mongodb-database-in-kubernetes-with-statefulsets/</link>
      <pubDate>Fri, 11 Jan 2019 17:52:48 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/running-mongodb-database-in-kubernetes-with-statefulsets/</guid>
      <description>지금까지의 과정 중에서 가장 어려웠다.;;; 그리고 제대로 이해를 한건지도 잘 모르겠다.
일단을 이해했다고 생각되는 정도만 정리를 해봤다.
이번 과정은 StatefulSet에 대한 이해를 목표로 하고 있다.
StatefulSet에 대한 이해를 위해서는 Headless Service에 대한 이해와 StorageClass에 대한 이해가 필요했다.
StorageClass는 상태를 갖는걸 확인하기 위한 실습이 필요하다보니, Volume을 사용해야 하고 StatefulSet의 scale을 조정하게 되는 것에 따라서 Volume도 같이 조정이 되어야 해서 StorageClass 컨트롤러를 통해서 Volume을 동적으로 조정할 수 있도록 하려고 사용 된 것 같다.</description>
    </item>
    
    <item>
      <title>5.Continuous Delivery With Jenkins in Kubernetes Engine</title>
      <link>https://shrinklabs.com/posts/continuous-delivery-with-jenkins-in-kubernetes-engine/</link>
      <pubDate>Thu, 10 Jan 2019 11:40:50 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/continuous-delivery-with-jenkins-in-kubernetes-engine/</guid>
      <description>이번 과정은 Jenkins와 Kubernetes를 이용한 배포 자동화를 실습해 볼 수 있었다.
분량은 많지만 이해가 어렵지는 않은 내용이었다.
실습을 해보면서 Namespace라는 객체와 Helm이라는 패키지 관리 도구를 사용해 볼 수 있다. Namespace는 일반적으로 우리가 알고 있는 용도인데, 논리적으로 무언가를 구분지어서 사용하고 싶을때 사용하는게 목적이라고 보면 될 것 같다.
이전 과정에서 배웠던 배포를 위한 전략에서는 label을 사용했었다면, 이번에는 Namespace를 사용해서 비슷한 문제 상황을 해결하는걸 경험해 볼 수 있다.
그리고 helm은 Kubernetes의 클러스터에 올라갈 수 있도록 미리 정의해서 배포해 놓은걸 사용할 수 있게 해주는 도구였다.</description>
    </item>
    
    <item>
      <title>4.Managing Deployments Using Kubernetes</title>
      <link>https://shrinklabs.com/posts/managing-deployments-using-kubernetes/</link>
      <pubDate>Wed, 09 Jan 2019 11:15:55 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/managing-deployments-using-kubernetes/</guid>
      <description>이번 장에서는 &amp;ldquo;Deployment&amp;rdquo;가 어떤 역할을 할 수 있으며, 이를 이용해서 취할 수 있는 배포 전략에 대해서 알아볼 수 있었다.
(이번 장에서 실습을 위해서는 필수적으로 compute/zone 설정을 us-central1-a로 지정해 놓아야 cluster 생성을 정상적으로 할 수 있다.)
Deployment 뿐만이 아니라 다른 객체들을 사용하기 위해서도 yaml을 작성할때 각 필드에 대한 정보를 어디에서 확인해야 하는지가 궁금했다.
$ kubectl explain deployment $ kubectl explain --recursive $ kubectl explain deployment.metadata.name  등과 같이 확인을 할 수 있다.</description>
    </item>
    
    <item>
      <title>3.Orchestrating the Cloud With Kubernetes</title>
      <link>https://shrinklabs.com/posts/orchestrating-cloud-with-kubernetes/</link>
      <pubDate>Wed, 09 Jan 2019 01:26:47 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/orchestrating-cloud-with-kubernetes/</guid>
      <description>이번 장은 우선 &amp;ldquo;nginx&amp;rdquo;와 &amp;ldquo;monolith&amp;rdquo;라는 단어에 현혹되지 않도록 주의를 해야 할 것 같다.
최초에 nginx가 실행되는 Pod는 그거대로 Kubnernetes 작동에 대한 내용이고, Pod에 대한 내용에서 언급되는 nginx와 monolith는 또 그것대로의 내용을 설명한다.
그리고 다음에 나오는 port-forward에 대한 내용은 또 완전히 별개의 내용이다.
port-forward는 &amp;ldquo;Service&amp;rdquo;로 노출하지 않는 Pod에 대해서 테스트등을 해보기 위해서 아주 유용한 도구인 것 같다.
port-forward로 &amp;ldquo;monolith&amp;rdquo; Pod의 80 포트를 10080을 지정하면 local의 10080 포트를 사용하고 있는것 처럼 이용이 가능하다.</description>
    </item>
    
    <item>
      <title>2.Hello Node Kubernetes</title>
      <link>https://shrinklabs.com/posts/hello-node-kubernetes/</link>
      <pubDate>Tue, 08 Jan 2019 13:13:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/hello-node-kubernetes/</guid>
      <description>2번째 과정에서는 Kubernetes의 기본적인 동작 방식에 대해서 알아 볼 수 있었다.
Kubernetes의 클러스터를 생성하는 과정은 Google Cloud Platform에서 기능을 제공하고 있어서 아주 간편했다.
책을 보면서 Kubernetes 공부를 처음 시작하는 과정에서 가장 시간을 많이 소비하게 되는 부분이었는데, 플랫폼에서 제공되는 기능을 glcoud를 이용해서 node와 각 node의 기본적인 설정을 지정후 cluster를 생성하는 명령 하나로 모든 과정이 생략될 수 있게 되었다.
그리고 Registry Server에 등록해 놓았던 Image를 이용해서 직접 &amp;ldquo;Pod&amp;rdquo;를 만들어보고, &amp;ldquo;Pod&amp;rdquo;의 개념과 &amp;ldquo;Deployment&amp;rdquo;의 개념이 무엇인지에 대해서 대략적으로 알아 볼 수 있었다.</description>
    </item>
    
    <item>
      <title>1.Introduction to Docker</title>
      <link>https://shrinklabs.com/posts/introduction-to-docker/</link>
      <pubDate>Tue, 08 Jan 2019 10:48:08 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/introduction-to-docker/</guid>
      <description>구글에서 지원해주는 “2019 클라우드 스터디잼 입문반” 스터디에 참여하기 시작했다. 이 스터디는 어떠한 형태로든 모인 멤버들이 일정 기간(1&amp;frasl;7~1&amp;frasl;27) 동안에 실습이 겸해진 과정(QWIKLABS - Kubernetes in the Google Cloud)을 완수하는 방식이다.
첫번째 과정으로 “Introduction to Docker” 을 진행 했다. 다음은 과정을 진행하면서 학습할 수 있었던 내용의 요약이다.
처음 해보는 과정이라서 그런지 익숙해지기 위한 시간이 약간 필요했지만 그다지 어렵지는 않았다.
Docker의 Image와 Container 그리고 Dockerfile의 이해를 위한 몇 가지의 실습이 진행되었다. 실습들을 통해서 Image와 Container를 어떻게 구분지어서 생각해야 하는지를 학습할 수 있었다.</description>
    </item>
    
    <item>
      <title>docker 시작하기</title>
      <link>https://shrinklabs.com/posts/docker/</link>
      <pubDate>Thu, 27 Jul 2017 00:25:51 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/docker/</guid>
      <description>docker ce 설치  오래된 버전 제거
$ sudo apt-get remove docker docker-engine docker.io  패키지 인덱스 업데이트
$ sudo apt-get update  apt가 https를 통해서 저장소를 사용할 수 있도록 패키지를 설치
$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common  docker의 공식 GPG 키를 추가
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -  fingerprint를 확인
$ sudo apt-key fingerprint 0EBFCD88  안정화 버전의 저장소를 추가</description>
    </item>
    
  </channel>
</rss>