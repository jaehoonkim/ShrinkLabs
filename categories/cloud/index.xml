<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cloud on ShrinkLabs</title>
    <link>https://shrinklabs.com/categories/cloud/</link>
    <description>Recent content in cloud on ShrinkLabs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 19 May 2020 01:05:57 +0900</lastBuildDate><atom:link href="https://shrinklabs.com/categories/cloud/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Windows기반의 minikube로 로컬 환경의 image 사용해서 배포하기</title>
      <link>https://shrinklabs.com/post/container_kubectl_run/</link>
      <pubDate>Tue, 19 May 2020 01:05:57 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_kubectl_run/</guid>
      <description>실제 클러스터에 배포하기 전에 로컬 환경의 minikube를 이용해서 배포하고 테스트를 하기 위한 방법이 필요하면 다음과 같이 합니다.
minikube를 시작하고, minikube에 내장되어 있는 docker 데몬을 사용하도록 합니다. 이렇게 하면 호스트 머신의 Docker Registry를 사용하고 image도 호스트 머신에 생성해 놓은 것을 사용할 수 있습니다.
(https://kubernetes.io/docs/setup/learning-environment/minikube/#use-local-images-by-re-using-the-docker-daemon)
PS&amp;gt; minikube docker-env $Env:DOCKER_TLS_VERIFY = &amp;#34;1&amp;#34; $Env:DOCKER_HOST = &amp;#34;tcp://192.168.182.22:2376&amp;#34; $Env:DOCKER_CERT_PATH = &amp;#34;C:\Users\jaehoonn\.minikube\certs&amp;#34; # Run this command to configure your shell: # &amp;amp; minikube docker-env | Invoke-Expression PS&amp;gt; minikube docker-env | Invoke-Expression 이렇게 하면, minikube vm 안에 존재하는 docker 데몬과 통신을 하게 됩니다.</description>
    </item>
    
    <item>
      <title>Kubernetes에서 Private Container Registry 사용</title>
      <link>https://shrinklabs.com/post/container_private-container-registry/</link>
      <pubDate>Fri, 10 Apr 2020 16:31:48 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_private-container-registry/</guid>
      <description>Kubernetes에 배포하기 위해서 Container Registry(Private)을 사용하려면, 별도의 secret을 등록해야 합니다.
$ kubectl create secret docker-registry {secret} \ --docker-server={registryserver} \ --docker-username={name} \ --docker-password={password} \ --docker-email={email} \ --namespace={namespace} namespace는 지정하지 않으면 default로 지정됩니다.
그리고 Container Registry로 부터 image를 받아서 사용하기 위한 yaml 파일에 다음과 같이 추가합니다.
apiVersion: v1 kind: Pod metadata: name: private-reg spec: containers: - name: private-reg-container image: regcred/projectaa/private-reg:latest imagePullSecrets: - name: regcred &amp;ldquo;imagePullSecrets&amp;rdquo; 항목을 추가하고 containers.image에서 iamgePullSecretes.name을 base로 사용합니다.
   (adsbygoogle = window.</description>
    </item>
    
    <item>
      <title>GCE에서 kops를 이용한 K8s 구성</title>
      <link>https://shrinklabs.com/post/container_k8s-with-kops-on-gce/</link>
      <pubDate>Thu, 05 Mar 2020 21:36:13 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_k8s-with-kops-on-gce/</guid>
      <description>클러스터 배포용 VM 인스턴스 생성  Kubernetes를 구성하기 위한 VM 인스턴스를 생성합니다. &amp;ldquo;ID 및 API 액세스&amp;rdquo; 항목에서 액세스 범위를 &amp;ldquo;모든 Cloud API에 대한 전체 액세스 허용&amp;rdquo; 으로 선택한다. 또는 아래와 같이 서비스 계정에 권한을 설정하고 서비스 계정을 선택해도 됩니다.  GCP 관리 콘솔의 IAM&amp;amp;Admin에서 서비스 계정을 하나 만듭니다. 서비스 계정이 갖고 있어야 하는 최소한의 권한은 다음과 같습니다.  compute admin servce account admin service account key admin service account token creator service acount user storage admin DNS Administrator DNS Reader  SSH로 연결 &amp;amp; 업데이트  jaehoonn@jaehoonn:~$sudo apt-get update jaehoonn@jaehoonn:~$sudo apt-get dist-upgrade   kubectl 설치 jaehoonn@jaehoonn:~$curl -LO https://storage.</description>
    </item>
    
    <item>
      <title>10.Nginx Ingress Controller on Google Kubernetes Engine</title>
      <link>https://shrinklabs.com/post/container_nginx-ingress-controller-on-google-kubernetes-engine/</link>
      <pubDate>Mon, 21 Jan 2019 17:05:30 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_nginx-ingress-controller-on-google-kubernetes-engine/</guid>
      <description>이번 과정에서는 &amp;ldquo;Ingress&amp;quot;에 대해서 알아 볼 수 있었습니다.
&amp;ldquo;Ingress&amp;quot;는 resource와 controller로 구성되어 있습니다.
resource는 &amp;ldquo;Ingress&amp;quot;의 동작에 대한 규칙을 정해 놓은 yaml이며,
controller는 layer7에 해당하는 로드밸런서의 역할을 제공합니다. 즉 http 요청에 대한 처리와 부하 분산을 제공합니다.
controller로는 gce, nginx, envoy, haproxy, istio, kong, traefik 을 이용할 수 있습니다.
과정에서는 &amp;ldquo;hello-app&amp;rdquo; 이라는 &amp;ldquo;Service&amp;quot;를 노출합니다. 그리고 helm을 이용해서 nginx-ingress를 kubernetes cluster에 설치합니다.
kind가 &amp;ldquo;Ingress&amp;quot;인 yaml 파일을 만듭니다. 이때 &amp;ldquo;path: /hello&amp;quot;로 지정하며, backend를 &amp;ldquo;serviceName: hello-app&amp;quot;과 &amp;ldquo;servicePort: 8080&amp;rdquo; 으로 지정을 합니다.</description>
    </item>
    
    <item>
      <title>9.Helm Package Management</title>
      <link>https://shrinklabs.com/post/container_helm-package-management/</link>
      <pubDate>Thu, 17 Jan 2019 15:04:00 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_helm-package-management/</guid>
      <description>이번 과정은 kubernetes에서 사용할 수 있는 패키지 관리자에 대해서 알아 볼 수 있었습니다.
Helm은 클라이언트 역할을 하는 helm, 서버 역할을 하는 tiller 그리고 설정 정보들의 관리를 위한 chart로 이루어져 있습니다.
여기에서 클라이언트(helm)라고 하는건 클러스터의 외부에서 작업을 지시하기 위한 도구이고, 실제로 클러스터 안쪽에서 동작 하는건 서버(tiller)라고 보면 됩니다.
helm의 설치는 간단합니다.
$ curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get &amp;gt; get_helm.sh $ chmod 700 get_helm.sh $ ./get_helm.sh 근데 이 과정 다음에 갑자기 tiller를 위한 계정을 만들고 해당 계정을 무언가에 바인딩을 합니다.</description>
    </item>
    
    <item>
      <title>8.Setting Up a Private Kubernetes Cluster</title>
      <link>https://shrinklabs.com/post/container_setting-up-private-kubernetes-cluster/</link>
      <pubDate>Wed, 16 Jan 2019 01:46:28 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_setting-up-private-kubernetes-cluster/</guid>
      <description>이번 과정의 실습을 진행하면서 클러스터에 대한 접근을 제한 할 수 있도록 하기 위한 방법에 대해서 알 수 있었습니다. 하지만 전체 내용에 대해서 정확하게 이해를 하지 못했습니다.
해당 내용은 이후에 비공개 클러스터 설정(https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters) 에 대한 내용이 실습 내용과 동일하므로 추후에 이해가 가능한 시점이 되면 다시 한번 시도해 보려고 합니다.
아래는 내용을 이해하기 위해서 학습했던 내용들의 링크입니다.
  네트워크 입문: http://kujung.tistory.com/category/%EB%98%A5%20%EC%8B%B8%EA%B8%B0/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC
  IPv4 네트워크 주소와 호스트 주소/서브넷팅/IP Class: http://itsaessak.tistory.com/174
  IP 주소체계와 클래스 구별법 (IPV4): http://korean-daeddo.</description>
    </item>
    
    <item>
      <title>7.Build Slack Bot With Node.js on Kubernetes</title>
      <link>https://shrinklabs.com/post/container_build-slack-bot-with-nodejs-on-kubernetes/</link>
      <pubDate>Mon, 14 Jan 2019 13:17:21 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_build-slack-bot-with-nodejs-on-kubernetes/</guid>
      <description>이번 과정은 Secret 객체에 대해서 좀 더 자세하게 알아볼 수 있는 과정이었습니다.
서비스를 제공하는 프로그램(node.js 코드)을 Docker image로 만든 다음 Registry Server에 Push를 합니다.
제공하는 서비스에서 외부의 서비스(slack)를 사용하기 위해서 민감한 정보인 token이 존재한다. 이 내용이 코드상 또는 image 상에 존재하지 않게 Image를 만들고자 합니다.
그래서 별도로 &amp;ldquo;slack-token&amp;rdquo; 파일을 만들어서 파일을 통해서 token 정보를 제공하도록 만들어 놓았습니다. 해당 파일을 경로와 파일명을 포함해서 환경변수 &amp;ldquo;slack_token_path&amp;quot;에 등록해 놓고, 코드상에서는 환경 변수인 &amp;ldquo;slack_token_path&amp;quot;에 지정되어 있는 경로의 파일로 부터 token 정보를 읽어서 사용합니다.</description>
    </item>
    
    <item>
      <title>6.Running Mongodb Database in Kubernetes With Statefulsets</title>
      <link>https://shrinklabs.com/post/container_running-mongodb-database-in-kubernetes-with-statefulsets/</link>
      <pubDate>Fri, 11 Jan 2019 17:52:48 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_running-mongodb-database-in-kubernetes-with-statefulsets/</guid>
      <description>지금까지의 과정 중에서 가장 어려웠습니다.;;; 그리고 제대로 이해를 한건지도 잘 모르겠습니다.
일단을 이해했다고 생각되는 정도만 정리를 해봤습니다.
이번 과정은 StatefulSet에 대한 이해를 목표로 하고 있습니다.
StatefulSet에 대한 이해를 위해서는 Headless Service에 대한 이해와 StorageClass에 대한 이해가 필요했습니다.
StorageClass는 상태를 갖는걸 확인하기 위한 실습이 필요하다보니, Volume을 사용해야 하고 StatefulSet의 scale을 조정하게 되는 것에 따라서 Volume도 같이 조정이 되어야 해서 StorageClass 컨트롤러를 통해서 Volume을 동적으로 조정할 수 있도록 하려고 사용 된 것 같습니다.</description>
    </item>
    
    <item>
      <title>5.Continuous Delivery With Jenkins in Kubernetes Engine</title>
      <link>https://shrinklabs.com/post/container_continuous-delivery-with-jenkins-in-kubernetes-engine/</link>
      <pubDate>Thu, 10 Jan 2019 11:40:50 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_continuous-delivery-with-jenkins-in-kubernetes-engine/</guid>
      <description>이번 과정은 Jenkins와 Kubernetes를 이용한 배포 자동화를 실습해 볼 수 있었습니다.
분량은 많지만 이해가 어렵지는 않은 내용이었습니다.
실습을 해보면서 Namespace라는 객체와 Helm이라는 패키지 관리 도구를 사용해 볼 수 있습니다. Namespace는 일반적으로 우리가 알고 있는 용도인데, 논리적으로 무언가를 구분지어서 사용하고 싶을때 사용하는게 목적이라고 보면 될 것 같습니다.
이전 과정에서 배웠던 배포를 위한 전략에서는 label을 사용했었다면, 이번에는 Namespace를 사용해서 비슷한 문제 상황을 해결하는걸 경험해 볼 수 있습니다.
그리고 helm은 Kubernetes의 클러스터에 올라갈 수 있도록 미리 정의해서 배포해 놓은걸 사용할 수 있게 해주는 도구였습니다.</description>
    </item>
    
    <item>
      <title>4.Managing Deployments Using Kubernetes</title>
      <link>https://shrinklabs.com/post/container_managing-deployments-using-kubernetes/</link>
      <pubDate>Wed, 09 Jan 2019 11:15:55 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_managing-deployments-using-kubernetes/</guid>
      <description>이번 장에서는 &amp;ldquo;Deployment&amp;quot;가 어떤 역할을 할 수 있으며, 이를 이용해서 취할 수 있는 배포 전략에 대해서 알아볼 수 있었습니다.
(이번 장에서 실습을 위해서는 필수적으로 compute/zone 설정을 us-central1-a로 지정해 놓아야 cluster 생성을 정상적으로 할 수 있습니다.)
Deployment 뿐만이 아니라 다른 객체들을 사용하기 위해서도 yaml을 작성할때 각 필드에 대한 정보를 어디에서 확인해야 하는지가 궁금했습니다.
$ kubectl explain deployment $ kubectl explain --recursive $ kubectl explain deployment.metadata.name 등과 같이 확인을 할 수 있습니다.</description>
    </item>
    
    <item>
      <title>3.Orchestrating the Cloud With Kubernetes</title>
      <link>https://shrinklabs.com/post/container_orchestrating-cloud-with-kubernetes/</link>
      <pubDate>Wed, 09 Jan 2019 01:26:47 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_orchestrating-cloud-with-kubernetes/</guid>
      <description>이번 장은 우선 &amp;ldquo;nginx&amp;quot;와 &amp;ldquo;monolith&amp;quot;라는 단어에 현혹되지 않도록 주의를 해야 할 것 같습니다.
최초에 nginx가 실행되는 Pod는 그거대로 Kubnernetes 작동에 대한 내용이고, Pod에 대한 내용에서 언급되는 nginx와 monolith는 또 그것대로의 내용을 설명합니다.
그리고 다음에 나오는 port-forward에 대한 내용은 또 완전히 별개의 내용입니다.
port-forward는 &amp;ldquo;Service&amp;quot;로 노출하지 않는 Pod에 대해서 테스트등을 해보기 위해서 아주 유용한 도구인 것 같습니다.
port-forward로 &amp;ldquo;monolith&amp;rdquo; Pod의 80 포트를 10080을 지정하면 local의 10080 포트를 사용하고 있는것 처럼 이용이 가능합니다.</description>
    </item>
    
    <item>
      <title>2.Hello Node Kubernetes</title>
      <link>https://shrinklabs.com/post/container_hello-node-kubernetes/</link>
      <pubDate>Tue, 08 Jan 2019 13:13:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_hello-node-kubernetes/</guid>
      <description>2번째 과정에서는 Kubernetes의 기본적인 동작 방식에 대해서 알아 볼 수 있었습니다.
Kubernetes의 클러스터를 생성하는 과정은 Google Cloud Platform에서 기능을 제공하고 있어서 아주 간편했습니다.
책을 보면서 Kubernetes 공부를 처음 시작하는 과정에서 가장 시간을 많이 소비하게 되는 부분이었는데, 플랫폼에서 제공되는 기능을 glcoud를 이용해서 node와 각 node의 기본적인 설정을 지정후 cluster를 생성하는 명령 하나로 모든 과정이 생략될 수 있게 되었습니다.
그리고 Registry Server에 등록해 놓았던 Image를 이용해서 직접 &amp;ldquo;Pod&amp;quot;를 만들어보고, &amp;ldquo;Pod&amp;quot;의 개념과 &amp;ldquo;Deployment&amp;quot;의 개념이 무엇인지에 대해서 대략적으로 알아 볼 수 있었습니다.</description>
    </item>
    
    <item>
      <title>1.Introduction to Docker</title>
      <link>https://shrinklabs.com/post/container_introduction-to-docker/</link>
      <pubDate>Tue, 08 Jan 2019 10:48:08 +0900</pubDate>
      
      <guid>https://shrinklabs.com/post/container_introduction-to-docker/</guid>
      <description>구글에서 지원해주는 “2019 클라우드 스터디잼 입문반” 스터디에 참여하기 시작했습니다. 이 스터디는 어떠한 형태로든 모인 멤버들이 일정 기간(1/7~1/27) 동안에 실습이 겸해진 과정(QWIKLABS - Kubernetes in the Google Cloud)을 완수하는 방식입니다.
첫번째 과정으로 “Introduction to Docker” 을 진행 했습니다. 다음은 과정을 진행하면서 학습할 수 있었던 내용의 요약입니다.
처음 해보는 과정이라서 그런지 익숙해지기 위한 시간이 약간 필요했지만 그다지 어렵지는 않았습니다.
Docker의 Image와 Container 그리고 Dockerfile의 이해를 위한 몇 가지의 실습이 진행되었습니다. 실습들을 통해서 Image와 Container를 어떻게 구분지어서 생각해야 하는지를 학습할 수 있었습니다.</description>
    </item>
    
  </channel>
</rss>
