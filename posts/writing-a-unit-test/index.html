<!DOCTYPE html>
<html class="no-js" lang="ko-kr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Go언어 프로젝트에서 테스트 코드 작성 경험 - ShrinkLabs</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	
	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="ShrinkLabs" rel="home">
				<div class="logo__title">ShrinkLabs</div>
				<div class="logo__tagline">컨테이너관리 솔루션을 만들면서 경험하는 삽질에 대한 로그.</div>
			</a>
		</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go언어 프로젝트에서 테스트 코드 작성 경험</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2018-02-21T23:02:29&#43;09:00">February 21, 2018</time>
</div>

<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/code/" rel="category">code</a>
	</span>
</div></div>
		</header><div class="content post__content clearfix">
			

<p>주의, 아래의 내용은 학습을 하면서 이해한 정도에서의 정리라서 틀린 내용이 많이 있을 수 있습니다. 이제 테스트 코드 작성을 시도해보기 시작하는 뉴비라서… 잘못된 부분은 지적을 해주시면 감사한 마음으로 배우겠습니다.</p>

<h2 id="테스트-코드는-왜">테스트 코드는 왜?</h2>

<p>현재 프로젝트를 진행 중 코딩을 할 때면 계속해서 의심과 두려움이 들었다.</p>

<p>&ldquo;내가 제대로 작성하고 있는 게 맞나?&rdquo;<br />
&ldquo;이렇게 작성하면 다른 데에서 문제가 생기는 건 아닌가?&rdquo;</p>

<p>그리고 이런 걱정들은 다음의 2가지 원인 때문이지 않을까 라고 생각하게 되었다.<br />
첫 번째, 코드 작성 후 실행해서 결과를 확인하기 위해서 개인 개발 환경을 MessageQueue와 내가 보낸 요청에 대해 기대하는 응답을 전달해줄 MessageQueue 반대편의 모듈을 구성하기가 쉽지 않다는 것이었다.<br />
두 번째, 기존에 코딩하면서 세워 놓았던 원칙을 기억하지 못하고 그 원칙에 어긋나는 코드를 작성하게 되었을 때, 전체 시스템에서 동작 중 알 수 없는 순간에 오동작하는 경우 때문이었다.</p>

<p>&ldquo;테스트 주도 개발 TDD 실천법과 도구&rdquo; 라는 책과 함께 몇 가지의 블로그 포스팅 그리고 몇 권의 책을 더 읽어 보면서 테스트 코드를 작성해 보면 문제의 원인을 해결할 수 있지 않을까 싶었다.<br />
그래서 진행중인 프로젝트들에 테스트 코드를 작성해 보기로 했다.</p>

<h2 id="테스트-코드는-뭘">테스트 코드는 뭘?</h2>

<p>테스트 코드를 작성할 때에 주의해야 할 점은 다음과 같다.</p>

<ol>
<li>&ldquo;질문 -&gt; 응답 -&gt; 정제 -&gt; 반복&rdquo; 의 과정을 거쳐서, 테스트를 작성하고 실패하고 정리하고  이걸 반복한다.</li>
<li>테스트 작성의 최소 단위는 함수이다. 하나의 함수를 기준으로 테스트 코드를 작성할 수 있다.</li>
<li>설계할 때 동작을 먼저 정의하고 그 동작에 필요한 속성을 고려한다.</li>
</ol>

<h2 id="테스트-코드는-어떻게">테스트 코드는 어떻게?</h2>

<p>Go 언어에서 테스트 코드의 작성은 표준으로 제공하는 “testing” 패키지만으로 가능하다.</p>

<p>테스트 코드 작성과 확인을 좀 더 편리하게 도와주는 다음과 같은 도구들의 도움을 받을 수도 있다.</p>

<ul>
<li>testify ( go get -u github.com/stretchr/testify )<br /></li>
<li>goconvey ( go get -u github.com/smartystreets/goconvey )<br /></li>
</ul>

<p>testify는 assert, http, mock, require, suite 와 같은 패키지를 제공해서 좀 더 편리한 검증을 할 수 있도록 도와준다. 그리고 goconvey는 터미널(go test)에서 테스트 결과를 확인하던걸 브라우저에서 편리하게 확인할 수 있게 해주는 도구이다.</p>

<p>goconvey의 사용은 테스트를 진행할 디렉토리에서 goconvey를 실행해 주면 웹브라우저가 실행되면서 다음과 같은 화면으로 현재 프로젝트의 테스트 상황을 한 눈에 볼 수 있게 해준다.<br />
<img src="/writing-a-unit-test/scr-1.png" alt="" /></p>

<p>또한, 현재 coverage 상태를 다음과 같이 볼 수도 있다.<br />
<img src="/writing-a-unit-test/scr-2.png" alt="" /></p>

<h2 id="테스트-코드-작성">테스트 코드 작성</h2>

<p>테스트 함수 작성 요령</p>

<ul>
<li><p>테스트 대상 함수와 이름을 1:1로 일치시킨다.</p>

<pre><code>대상: Getbalance() {...}  
테스트: TestGetbalance(...) {...}
</code></pre></li>

<li><p>테스트 대상 메소드의 이름을 메소드 단위로 작성을 하면서 뒤에 추가적인 케이스에 대한 내용을 추가한다.</p>

<pre><code>func Test_Withdraw_마이너스통장인출(...) {...}
</code></pre></li>

<li><p>특정한 메소드가 아닌 테스트 시나리오를 대상으로 하는 테스트 메소드를 작성하는 경우도 있다.</p>

<pre><code>func Test_VIP고객이_인출할때_수수료계산(...) {...}
</code></pre></li>

<li><p>테스트 케이스 시나리오는 정상적인 흐름에 대한 결과를 확인하거나, 예외나 에러 상황에 대한 결과를 확인하는 방법이 있을 수 있다. 그리고 a+b의 동작을 하는 메소드에 a와 b를 넣고 실제로 a+b를 한 결과와 일치하는지 확인해 보는 식의 경우가 있다.</p></li>
</ul>

<p>Go 언어로 만들어진 프로젝트에서 테스트 코드를 작성하기 위해서는 몇 가지 규칙이 있다.</p>

<ul>
<li>파일명이 &ldquo;xxx_test.go&rdquo; 와 같이 파일명 뒤에 _test라고 지정한다.</li>

<li><p>테스트를 진행할 함수의 이름은 &ldquo;Test&rdquo; 로 시작되어야 한다.</p>

<pre><code>func Test_Minus_작은_수에서_큰_수_빼기(t *testing.T) { }
</code></pre></li>

<li><p>위의 ex에서 보이는 것 처럼 testing.T 를 인자로 받는다. testing.T 타입은 Error, Fail, Fatal, Log 등과 같은 테스트에 필요한 요소들을 갖고 있다.
(자세한 내용은 <a href="https://golang.org/pkg/testing/">https://golang.org/pkg/testing/</a> 을 참고)</p></li>
</ul>

<h2 id="테스트-코드-작성-예-1">테스트 코드 작성 예(1)</h2>

<p>간단한 더하기 계산을 하는 패키지를 만들면서 필요한  테스트 코드를 작성하는 예를 한번 보자.<br />
테스트 코드는 다음과 같다.</p>

<pre><code class="language-go">// add_test.go
package add

import (
	&quot;testing&quot;
)

func TestAdd(t *testing.T) {
	//arrange
	var x, y, res int
	x = 2
	y = 3

	//act
	res = Add(x, y)

	//assert
	if res != 5 {
		t.Fatal(&quot;Add의 결과가 옳바르지 않습니다&quot;)
	}
}
</code></pre>

<p>add 패키지의 구현은 다음과 같다.</p>

<pre><code class="language-go">// add.go
package add

func Add(x, y int) int {
	return x + y
}
</code></pre>

<p>이제 테스트를 진행해서 결과를 보기 위해서 다음과 같이 실행한다.</p>

<pre><code>$ go test -v
=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
</code></pre>

<h2 id="테스트-코드-작성-예-2">테스트 코드 작성 예(2)</h2>

<p>이번에는 testify/assert 패키지를 이용한 테스트 코드 작성 예를 한번 보도록 하겠다. 그리고 현재 프로젝트 디렉토리에서 goconvey를 실행해서 브라우저를 통해서 테스트 함수들의 성공 또는 실패를 계속해서 확인해보자.</p>

<pre><code>sample_1$ goconvey

2018/02/20 17:02:39 goconvey.go:61: Initial configuration: [host: 127.0.0.1] [port: 8080] [poll: 250ms] [cover: true]
2018/02/20 17:02:42 tester.go:19: Now configured to test 10 packages concurrently.
2018/02/20 17:02:42 goconvey.go:192: Serving HTTP at: http://127.0.0.1:8080
2018/02/20 17:02:42 integration.go:122: File system state modified, publishing current folders... 0 3038222316
2018/02/20 17:02:42 goconvey.go:118: Received request from watcher to execute tests...
2018/02/20 17:02:42 executor.go:69: Executor status: 'executing'
2018/02/20 17:02:42 coordinator.go:46: Executing concurrent tests: sample_1
2018/02/20 17:02:42 goconvey.go:105: Launching browser on 127.0.0.1:8080
2018/02/20 17:02:46 goconvey.go:113: ATTENTION: default value of option force_s3tc_enable overridden by environment.
기존 브라우저 세션에 새 창을 생성했습니다.
</code></pre>

<pre><code class="language-go">// oprcfg.go

type CfgItem struct {
  Name        string
  Value       string
  Owner       string
}

type Config struct {
  Cfg map[string][]CfgItem
}
 
func NewConfig() (*Config, error) {
  oc := &amp;Config{}
  oc.Cfg = make(map[string][]CfgItem)
  return oc, nil
}
 
func (oc *Config) GetOprCfg(owner string) []OprCfg {
  if owner == &quot;&quot; {
    return nil
  }
  
  globalCategory := &quot;global&quot;
  srchCategory := owner
 
  globalConfigItem := oc.Cfg[globalCategory]
  srchConfigItem := oc.Cfg[srchCategory]
 
  var resOpcf []OprCfg
 
  for _, cf := range globalConfigItem {
    opcf := OprCfg{Name: cf.Name, Value: cf.Value, Owner: cf.Owner}
    resOpcf = append(resOpcf, opcf)
  }
 
  for _, cf := range srchConfigItem {
    opcf := OprCfg{Name: cf.Name, Value: cf.Value, Owner: cf.Owner}
    resOpcf = append(resOpcf, opcf)
  }
 
  return resOpcf
}
</code></pre>

<p>Config 객체를 생성하는 NewConfig() 함수가 있고, Config에서 owner에 해당하는 OprCfg를 반환하는 GetOprCfg() 함수가 있다.<br />
이 두 함수에 대한 테스트 코드를 다음과 같이 작성했다.</p>

<pre><code class="language-go">// oprcfg_test.go

func Test_Config_New(t *testing.T) {
  // arrange
 
  // act
  oc, _ := NewConfig()
 
  // assert
  assert.NotNil(t, oc)
}
 
func Test_GetOprCfg(t *testing.T) {
  // arrange
  oc, _ := NewConfig()
 
  oc.SetCfgItem(&quot;key1&quot;, &quot;value1&quot;, &quot;key1-value1&quot;, &quot;owner1&quot;)
  oc.SetCfgItem(&quot;key2&quot;, &quot;value2&quot;, &quot;key2-value2&quot;, &quot;owner2&quot;)
  oc.SetCfgItem(&quot;key3&quot;, &quot;value3&quot;, &quot;key3-value3&quot;, &quot;owner1&quot;)
  oc.SetCfgItem(&quot;key4&quot;, &quot;value4&quot;, &quot;key4-value4&quot;, &quot;owner1&quot;)
  oc.SetCfgItem(&quot;key5&quot;, &quot;value5&quot;, &quot;key5-value5&quot;, &quot;owner2&quot;)
  oc.SetCfgItem(&quot;key6&quot;, &quot;value6&quot;, &quot;key6-value6&quot;, &quot;owner3&quot;)
  oc.SetCfgItem(&quot;key7&quot;, &quot;value7&quot;, &quot;key7-value7&quot;, &quot;owner1&quot;)
  oc.SetCfgItem(&quot;key8&quot;, &quot;value8&quot;, &quot;key8-value8&quot;, &quot;global&quot;)
 
  // act
  opcfs := oc.GetOprCfg(&quot;owner1&quot;)
  t.Log(opcfs)
 
  // assert
  var res []OprCfg
  res = make([]OprCfg, 5)
 
  // res에는 global이 먼저 쌓이고, 타겟 owner가 쌓인다
  res[0] = OprCfg{Name: &quot;key8&quot;, Value: &quot;value8&quot;, Owner: &quot;global&quot;}
  res[1] = OprCfg{Name: &quot;key1&quot;, Value: &quot;value1&quot;, Owner: &quot;owner1&quot;}
  res[2] = OprCfg{Name: &quot;key3&quot;, Value: &quot;value3&quot;, Owner: &quot;owener1&quot;}
  res[3] = OprCfg{Name: &quot;key4&quot;, Value: &quot;value4&quot;, Owner: &quot;owner1&quot;}
  res[4] = OprCfg{Name: &quot;key7&quot;, Value: &quot;value7&quot;, Owner: &quot;owner1&quot;}
  assert.True(t, assert.ObjectsAreEqual(&amp;res, &amp;opcfs))
}
</code></pre>

<p>테스트 코드를 작성하기 위해서 “Test” 로 시작하는 함수명을 갖도록 했다.<br />
func Test_Config_New(t *testing.T) 함수에서 보면, 다음과 같은 주석을 볼 수 있다.</p>

<pre><code>// arrange
...
// act
...
// assert
...
</code></pre>

<p>이는 테스트 코드를 작성하기 위한 일종의 템플릿 같은 것이다.<br />
arrange: 테스트를 진행하기 전에 필요한 준비 작업 정도의 코드들이 위치할 수 있다.
act: 실제로 테스트 되어서 결과를 확인하고자 하는 동작을 구현한다.<br />
assert: act에서 진행한 동작에 대한 결과를 확인하는 용도이다.</p>

<p>첫 번째 테스트 코드인 Test_Config_New는 Config 객체의 생성이 잘 되는지 확인하기 위한 테스트이다.</p>

<p>arrange 절은 준비할 작업이 별도로 없기 때문에 생략되었다.<br />
act 절에서 확인하고자 하는 NewConfig() 함수를 사용해서 Config 객체를 생성한다.
assert 절에서 생성된 객체가 생성이 잘 되었는지 확인하는 과정으로 객체가 nil인지를 확인한다. 여기에서 testify/assert 패키지를 사용한다.</p>

<p>assert 패키지에는 다양한 검증을 위한 기능을 제공하고 있다. 간단하게 assert.NotNil은 주어진 객체가 nil이 아닌지 확인하는 함수이다. assert의 다양한 기능에 대해서는 godoc( <a href="https://godoc.org/github.com/stretchr/testify/assert">https://godoc.org/github.com/stretchr/testify/assert</a> ) 에서 확인해볼 수 있다.</p>

<p>두 번째 테스트 코드인 Test_GetOprCfg는 Config에  다양한 owner의 CfgItem들이 섞여 있는 중에서, 특정 owner와 onwer가 global로 지정된 CfgItem을 찾아서 OprCfg 만들어서 반환해주는걸  확인하기 위한 용도의 테스트이다.</p>

<p>arrange 절에서 GetOprCfg 함수를 테스트하기 위해서 Config 객체를 생성해서 임의의 설정(CfgItem) 값들을 owner를 달리해서 입력(SetCfgItem)한다.<br />
act 절에서 GetOprCfg 함수에 owner로 &ldquo;owner1” 를 전달해서  OprCfg 슬라이스를 반환값으로 받는다.<br />
assert 절에서는 결과 값으로 받은 OperCfg 슬라이스가 global과 owner1이 owner인 값들만을 전달받았는지를 확인한다.</p>

<p>assert 패키지의 ObjectsAreEqual은 두 Object가 일치하는지를 확인한다.<br />
assert 패키지의 True는 전달받은 값이 true인지를 확인한다.</p>

<p>이렇게 기본적인 테스트 코드를 작성할 수 있다. 그렇지만 모든 상황에 대해서 테스트 코드를 작성할 수 있는 것은 아니며, 다음과 같은 경우에 대해서는 테스트 코드를 작성하는 데 한계가 있다.</p>

<ul>
<li>동시성 문제</li>
<li>접근제한자</li>
<li>GUI</li>
<li>의존성 모듈 테스트</li>
</ul>

<p>위의 경우는 고민하지 말고 테스트 코드 만들기를 포기하자&hellip;; (왜? 난 테스트 코드 작성 초보이니까!)</p>

<h2 id="테스트-코드-작성-예-3">테스트 코드 작성 예(3)</h2>

<p>의존성의 경우는 테스트더블을 이용해서 어느 정도는 해결(?) 할 수 있다. 예를 들어 다음과 같은 경우이다.</p>

<pre><code>패스워드 저장의 구현을 위해서 암호화 모듈을 제공 받아야 한다. 
암호화를 위한 인터페이스와 암호화 방식이 미리 정해져 있다면, 암호화 모듈을 Mock으로 제작할 수 있다. 
미리 약속된 인터페이스 기능들을 Cipher라는 인터페이스로 정의하고 
그 인터페이스를 구현한 MockMD5Cipher를 만들어서 encrypt와 decrypt 내부에서 
“potato”와 potato의 md5 hash 값을 무조건 반환해준다.
</code></pre>

<p>이러한 경우를 우리 프로젝트에서 생각해 보면 MessageQueue에 의존적인 환경에서 개발하고 있는걸 생각해 볼 수 있다. MessageQueue의 동작을 테스트더블 객체로 만들어서 테스트 코드를 작성해 볼 수 있다.</p>

<p>&ldquo;테스트더블&rdquo; 이라는 용어는 대역, 스턴트맨을 의미하는 스턴트 더블이라는 단어에서 유래되었다.<br />
데스트더블의 분류에는 &ldquo;Dummy&rdquo;, &ldquo;Stub&rdquo;, &ldquo;Fake&rdquo;, &ldquo;Spy&rdquo;, &ldquo;Mock&rdquo; 이 있다. 이들의 정의 또는 쓰임새는 다음과 같다.</p>

<ul>
<li>Dummy: 객체의 겉모양만 만들어서 테스트를 진행할 수 있도록 하는 목적의 객체이다. (객체가 생성만 되면 되는 경우에 사용한다)</li>
<li>Stub: 특정 메소드가 호출되어야 정상적인 동작이 가능한 경우에 사용하는 객체이다.(객체가 특정 상태나 모습을 갖추면 되기 때문에 필요한 메소드에 하드 코딩으로 결과 값 등을 작성한다.)</li>
<li>Fake: 여러 상황을 대표하기 위해 Stub보다 좀 더 복잡한 구현이 들어간 객체이다.</li>
<li>Spy: 특정한 메소드가 호출되었는지 확인하기 위한 용도로 호출된 내역을 내부에서 기록하는 로직이 들어간다.</li>
<li>Mock: 위의 테스트더블 객체들은 상태에 대한 확인이 주된 용도였다면 Mock은 행위를 검증하는 용도로 많이 사용된다.</li>
</ul>

<p>이제 MessageQueue에 의존적인 부분을 테스트더블 객체로 만들어서 테스트 코드를 작성해 보려고 한다.<br />
변경된 이벤트 정보를 확인하는 GetChangeEventInfo 함수에 대한 테스트 코드를 작성해 보자.<br />
테스트 코드를 작성하고자 하는 전체 로직은 다음과 같다.</p>

<ol>
<li>GetChangeEventInfo 함수가 호출되는 경우는 외부에서 이벤트가 변경되었음을 알리는 요청이 들어 온다.</li>
<li>전달받은 eventID 값을 이용해서 GetChangeEventInfo 함수가 MessageQueue에 연결되어 있는 Agent에게 변경된 이벤트 정보를 전달해 달라고 요청한다.</li>
<li>Agent는 Database에서 조회해서 MessageQueue에 결과를 전달할 것이다.</li>
<li>sample_1은 MessageQueue를 통해서 전달된 응답을 수집할 것이다.</li>
<li>결과로 받은 값을 확인한다.<br /></li>
</ol>

<p>테스트 코드를 작성하기 이전의 코드 상태는 다음과 같았다.</p>

<pre><code class="language-go">func (d *Agent) GetChangeEventInfo(eventID string) (*EventInfo, error) {
  *msg := MakeChangeMsg(“blah-blah-chg-key”, “agent”)*
 
  eventUUID := UUID_Data { UUID: eventID }
  any, _ := Any.Encoding(&amp;eventUUID)
  *msg.Payload(any)
 
  /* message queue 관련 기타 등등의 구현 들
      ...
  */
 
  SendMessage(msg)
  val := RecvMessage()

  data := val.GetPayload()
  var ei EventInfo
  Any.Decoding(data[0], &amp;ei)
 
  return &amp;ei, nil
}
</code></pre>

<p>위의 코드 중에서 굵게 표시된 부분은 sample_1 이 아닌 외부 요소(MessageQueue)들에 대한 동작을 구현한 부분이다.<br />
그리고 이 부분은 MessageQueue에 무언가를 요청하는 과정에서 매번 반복되기도 한다. 그래서 이 부분을 별도의 함수로 구현하기로 했다.</p>

<pre><code class="language-go">func (d *Agent) GetChangeEventInfo(eventID string) (*EventInfo, error) { 
  sendInfo := &amp;MqSendInfo{
    key:     “blah-blah-chg-key”,
    recv: “agent”,
  }
 
  eventUUID := UUID_Data{ UUID: eventID }
  any, _ := Any.Encoding(&amp;eventUUID)
 
  anyData, err := MqSend(sendInfo, any)
  if err != nil { return nil, err }
 
  var ei EventInfo
  Any.Decoding(anyData[0], &amp;ei)

  return &amp;ei, nil
}
</code></pre>

<p>위와 같이 코드를 별도의 함수(MqSend)로 빼놓고, MqSendInfo라는 struct를 인자로 받도록 변경을 했다. 함수와 구조체는 다음과 같이 작성되었다.</p>

<pre><code class="language-go">type MqSendInfo struct {
  key     string
  recv string
}
 
func MqSend(info *MqSendInfo, any *Any) ([]*Any, error) {
  msg := MakeChangeMsg(info.key, info.recv)
  
  msg.Payload(any)
 
  /* message queue 관련 기타 등등의 구현 들 
     ...
  */
 
  SendMessage(msg) 
  val := RecvMessage()
 
  return val.Msgs, nil
}
</code></pre>

<p>이렇게 해서 중복된 코드를 많이 줄일 수는 있었다. 그렇지만 MessageQueue의 의존성은 여전히 남아있다.</p>

<p>테스트 코드를 작성하는 입장에서는 우리가 전달한 eventID의 값을 이용해서 MqSend 함수가 EventInfo 값을 돌려주면된다. MqSend가 호출되었는지와 그 함수의 결과 값을 이용해서 GetChangeEventInfo가 우리가 원하는 결과 값을 만들어서 돌려주면 성공적으로 동작한 거로 간주할 수가 있게 된다.</p>

<p>그래서 MqSend 함수를 가짜로 구현하고 있는 테스트더블 객체를 만들려고 한다. +
우선 위의 MqSendInfo 구조체와 MqSend 함수의 이름을 MqMsg 구조체와 구조체의 메소드 Send로 변경하였다.</p>

<pre><code class="language-go">type Messenger interface {
  Send(any *Any) ([]*Any, error)
}
 
type MqMsg struct {
  key     string
  recv string
}

func (m *MqMsg) Send(any *Any) ([]*Any, error) {
  msg := MakeChangeMsg(m.key, m.recv)
 
  msg.Payload(any)
 
  /* message queue 관련 기타 등등의 구현 들 
     ...
  */
 
  SendMessage(msg)
  val := RecvMessage()

  return val.Msgs, nil
}
</code></pre>

<p>이제 테스트 코드를 다음과 같이 작성해 볼 수 있다.</p>

<pre><code class="language-go">type MockAgentMsgr struct {
  mock.Mock
}

func (m *MockAgentMsgr) Send(any *Any) ([]*Any, error) {
  args := m.Called(any, wait)
  return args.Get(0).([]*Any), args.Error(1)
}

func Test_GetChangeEventInfo(t *testing.T) {
  // arrange
 
  // 입력 값
  eventID := &quot;event--uuid-1&quot;
 
  UUID := UUID_Data { UUID: eventID }
  par1, _ := Any.Encoding(&amp;UUID)
 
  // 출력 값
  var resAnytypes []*Any
  res1 := EventInfo { UUID: eventID, Name: &quot;event1&quot;, Type: ET_START }
 
  resAnytype1, _ := Any.Encoding(&amp;res1)
  resAnytypes = append(resAnytypes, resAnytype1)
 
  m := &amp;MockAgentMsgr{}
  m.On(&quot;Send&quot;, par1).Return(resAnytypes, nil)
 
  agentMg := NewAgent(m)
 
  // act
  event, err := agentMg.GetChangeEventInfo(eventID)
 
  // assert
  assert.Equal(t, nil, err)
  assert.True(t, assert.ObjectsAreEqual(&amp;res1, event))
  assert.True(t, m.AssertCalled(t, &quot;Send&quot;, par1, true))
}
</code></pre>

<p>MqMsg의 테스트더블을 구현하기 위해서 Messenger 인터페이스에 Send 메소드를 정의했다.<br />
MockAgentMsgr 구조체는 Messenger 인터페이스를 구현한 테스트더블이다.<br />
MockAgentMsgr의 Send 메소드의 구현에서는 입력된 값과 반환되어야 할 값에 대해서 지정을 하고 있다.<br />
이제 Test_GetChangeEventInfo 함수에서 입력값을 만들고 Send 메소드가 호출되었을 때 반환해야 할 출력값도 지정한다. MessageQueue에서 어떤 동작을 하든지 상관없이 입력된 값에 의해서 정해진 결과 값을 받는다는 가정이다. 그래서 작성된 코드 중에 다음과 같은 내용이 있다.</p>

<pre><code class="language-go">m := &amp;MockAgentMsgr{}
m.On(&quot;Send&quot;, par1).Return(resAnytypes, nil)
</code></pre>

<p>Send 메소드가 호출될 때 입력값에 대해서 출력값을 정의해 놓은 것이다.</p>

<p>그런데 현재의 실행 코드상에서는 정해진 형태(MqMsg의 Send 메소드)만을 호출하는 구조이다. 이를 변경해야 할 필요가 있다. 그래서 우리는 Agent 객체를 생성하는 시점에 MessageQueue에 대한 정보를 지정해서 받는 형식으로 변경했다.</p>

<pre><code class="language-go">type Agent struct {
  Msgr Messenger
}
 
func NewAgent(msgr Messenger) *Agent {
  return &amp;Agent{Msgr: msgr}
}

func (d *Agent) GetChangeEventInfo(eventID string) (*EventInfo, error) {
  eventUUID := UUID_Data{ UUID: evnetID }
  any, _ := Any.Encoding(&amp;eventUUID)
 
  anyData, err := d.Msgr.Send(any)
  if err != nil { return nil, err }
 
  var ei EventInfo
  Any.Decoding(anyData[0], &amp;ei)
 
  return &amp;ei, nil
}
</code></pre>

<p>이제 테스트 코드에서처럼 NewAgent로 Agent 객체를 생성하기 전에 Messenger를 생성해서 전달받을 수 있게 되었다. (단, 실제로 Agent를 사용하는 시점에서는 매번 중복 코드가 발생하게 되었다. 이 부분은 다음에 다시 개선하기로 한다.)</p>

<p>이제 GetChangeEventInfo 함수를 구현하기 위해서 MessageQueue에 연결해서 디버깅하기 위한 과정 대신에 테스트 코드가 sample_1 에서 구현되어야 할 내용에 대해서 보장을 해줄 수 있게 되었다.</p>

<h2 id="결론">결론</h2>

<p>이제 입력되는 값과 MessageQueue 건너편의 대상으로부터 받기를 원하는 값에 대한 정의만 정확하다면, MessageQueue에 직접 연결되지 않아도 우리는 sample_1 의 기능을 구현할 수 있게 되었다.<br />
그리고 코딩 중에 세워졌던 원칙에 어긋나는 경우에 대해서 별도의 문서나 히스토리를 확인하지 않고 작성된 테스트 코드로 확인할 수 있게 되었다.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item"><a class="tags__link btn" href="/tags/go/" rel="tag">go</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/test/" rel="tag">test</a></li>
	</ul>
</div>
		</footer>
	</article>
</main>


<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--prev">
		<a class="post-nav__link" href="/posts/kvm-with-go/" rel="prev"><span class="post-nav__caption">«&thinsp;Previous</span><p class="post-nav__post-title">KVM 스터디(with go)</p></a>
	</div>
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/posts/key_exists_in_map/" rel="next"><span class="post-nav__caption">Next&thinsp;»</span><p class="post-nav__post-title">map에 key가 존재하는지 확인</p></a>
	</div>
</nav>


			</div>
			<aside class="sidebar"><div>
	<img src="img/profile.jpg" width=100 height=100>
</div>
<div class="widget-social widget">
	<h4 class="widget-social__title widget__title">Info</h4>
	<div class="widget-social__content widget__content">
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="GitHub" rel="noopener noreferrer" href="https://github.com/jaehoonkim" target="_blank">
				<svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
				<span>GitHub</span>
			</a>
		</div>
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="Email" href="mailto:jaehoon@shrinklabs.com">
				<svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16-256-16h-16-384-16zm347 16-139 92.5-139-92.5zm-148 125.5 9 5.5 9-5.5 167-111.5v210h-352v-210z"/></svg>
				<span>jaehoon@shrinklabs.com</span>
			</a>
		</div>

		
	</div>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/posts/private-container-registry/">Kubernetes에서 Private Container Registry 사용</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/docker-error/">docker 설치 후 에러</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/k8s-with-kops-on-gce/">GCE에서 kops를 이용한 K8s 구성</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/docker-image/">docker image 저장소 위치 변경</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/nginx-ingress-controller-on-google-kubernetes-engine/">10.Nginx Ingress Controller on Google Kubernetes Engine</a></li>
		</ul>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 ShrinkLabs.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>