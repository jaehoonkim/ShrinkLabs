<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ShrinkLabs</title>
    <link>https://shrinklabs.com/posts/</link>
    <description>Recent content in Posts on ShrinkLabs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Mon, 18 May 2020 10:52:23 +0900</lastBuildDate>
    
	<atom:link href="https://shrinklabs.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Crosscompile_on_windows</title>
      <link>https://shrinklabs.com/posts/crosscompile_on_windows/</link>
      <pubDate>Mon, 18 May 2020 10:52:23 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/crosscompile_on_windows/</guid>
      <description>Windows 환경에서 개발 후 Linux 환경으로 배포하기 위해서 Linux용 바이너리로 빌드를 해야 한다. 다음의 방법으로 빌드 할 수 있다.
Powershell에서 빌드를 한다.
PS D:\ws\src\sample&amp;gt; $env:GOOS=&amp;quot;linux&amp;quot;; go build  빌드 이후에는 필요에 따라서 &amp;ldquo;GOOS&amp;rdquo;를 다시 &amp;ldquo;windows&amp;rdquo;로 돌려 놓는다.</description>
    </item>
    
    <item>
      <title>Kubernetes에서 Private Container Registry 사용</title>
      <link>https://shrinklabs.com/posts/private-container-registry/</link>
      <pubDate>Fri, 10 Apr 2020 16:31:48 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/private-container-registry/</guid>
      <description>Kubernetes에 배포하기 위해서 Container Registry(Private)을 사용하려면, 별도의 secret을 등록해야 한다.
$ kubectl create secret docker-registry {secret} \ --docker-server={registryserver} \ --docker-username={name} \ --docker-password={password} \ --docker-email={email} \ --namespace={namespace}  namespace는 지정하지 않으면 default로 지정된다.
그리고 Container Registry로 부터 image를 받아서 사용하기 위한 yaml 파일에 다음과 같이 추가한다.
apiVersion: v1 kind: Pod metadata: name: private-reg spec: containers: - name: private-reg-container image: regcred/projectaa/private-reg:latest imagePullSecrets: - name: regcred  &amp;ldquo;imagePullSecrets&amp;rdquo; 항목을 추가하고 containers.image에서 iamgePullSecretes.name을 base로 사용한다.</description>
    </item>
    
    <item>
      <title>docker 설치 후 에러</title>
      <link>https://shrinklabs.com/posts/docker-error/</link>
      <pubDate>Wed, 08 Apr 2020 21:27:50 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/docker-error/</guid>
      <description>docker 설치 후 &amp;ldquo;Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?&amp;rdquo; 가 발생
$sudo systemctl status docker $sudo systemctl start docker $sudo systemctl enable docker  </description>
    </item>
    
    <item>
      <title>GCE에서 kops를 이용한 K8s 구성</title>
      <link>https://shrinklabs.com/posts/k8s-with-kops-on-gce/</link>
      <pubDate>Thu, 05 Mar 2020 21:36:13 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/k8s-with-kops-on-gce/</guid>
      <description>클러스터 배포용 VM 인스턴스 생성  Kubernetes를 구성하기 위한 VM 인스턴스를 생성한다.
 &amp;ldquo;ID 및 API 액세스&amp;rdquo; 항목에서 액세스 범위를 &amp;ldquo;모든 Cloud API에 대한 전체 액세스 허용&amp;rdquo; 으로 선택한다. 또는 아래와 같이 서비스 계정에 권한을 설정하고 서비스 계정을 선택해도 된다.
 GCP 관리 콘솔의 IAM&amp;amp;Admin에서 서비스 계정을 하나 만든다. 서비스 계정이 갖고 있어야 하는 최소한의 권한은 다음과 같다.
compute admin servce account admin service account key admin service account token creator service acount user storage admin DNS Administrator DNS Reader  SSH로 연결 &amp;amp; 업데이트</description>
    </item>
    
    <item>
      <title>docker image 저장소 위치 변경</title>
      <link>https://shrinklabs.com/posts/docker-image/</link>
      <pubDate>Thu, 05 Mar 2020 12:05:00 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/docker-image/</guid>
      <description> 새로운 디스크를 추가한다.
 여기에서는 &amp;ldquo;/docker&amp;rdquo; 에 mount 되어 있는걸로 가정한다.
  &amp;ldquo;etc/docker/daemon.json&amp;rdquo; 에 다음의 내용을 추가한다.
{ &amp;quot;data-root&amp;quot;: &amp;quot;/docker&amp;quot; }  docker 서비스를 재시작한다.
$ sudo systemctl daemon-reload $ sudo systemctl restart docker   </description>
    </item>
    
    <item>
      <title>10.Nginx Ingress Controller on Google Kubernetes Engine</title>
      <link>https://shrinklabs.com/posts/nginx-ingress-controller-on-google-kubernetes-engine/</link>
      <pubDate>Mon, 21 Jan 2019 17:05:30 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/nginx-ingress-controller-on-google-kubernetes-engine/</guid>
      <description>이번 과정에서는 &amp;ldquo;Ingress&amp;rdquo;에 대해서 알아 볼 수 있었다.
&amp;ldquo;Ingress&amp;rdquo;는 resource와 controller로 구성되어 있다.
resource는 &amp;ldquo;Ingress&amp;rdquo;의 동작에 대한 규칙을 정해 놓은 yaml이며,
controller는 layer7에 해당하는 로드밸런서의 역할을 제공한다. 즉 http 요청에 대한 처리와 부하 분산을 제공한다.
controller로는 gce, nginx, envoy, haproxy, istio, kong, traefik 을 이용할 수 있다.
과정에서는 &amp;ldquo;hello-app&amp;rdquo; 이라는 &amp;ldquo;Service&amp;rdquo;를 노출한다. 그리고 helm을 이용해서 nginx-ingress를 kubernetes cluster에 설치한다.
kind가 &amp;ldquo;Ingress&amp;rdquo;인 yaml 파일을 만든다. 이때 &amp;ldquo;path: /hello&amp;rdquo;로 지정하며, backend를 &amp;ldquo;serviceName: hello-app&amp;rdquo;과 &amp;ldquo;servicePort: 8080&amp;rdquo; 으로 지정을 한다.</description>
    </item>
    
    <item>
      <title>9.Helm Package Management</title>
      <link>https://shrinklabs.com/posts/helm-package-management/</link>
      <pubDate>Thu, 17 Jan 2019 15:04:00 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/helm-package-management/</guid>
      <description>이번 과정은 kubernetes에서 사용할 수 있는 패키지 관리자에 대해서 알아 볼 수 있었다.
Helm은 클라이언트 역할을 하는 helm, 서버 역할을 하는 tiller 그리고 설정 정보들의 관리를 위한 chart로 이루어져 있다.
여기에서 클라이언트(helm)라고 하는건 클러스터의 외부에서 작업을 지시하기 위한 도구이고, 실제로 클러스터 안쪽에서 동작 하는건 서버(tiller)라고 보면 된다.
helm의 설치는 간단합니다.
$ curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get &amp;gt; get_helm.sh $ chmod 700 get_helm.sh $ ./get_helm.sh  근데 이 과정 다음에 갑자기 tiller를 위한 계정을 만들고 해당 계정을 무언가에 바인딩을 한다.</description>
    </item>
    
    <item>
      <title>8.Setting Up a Private Kubernetes Cluster</title>
      <link>https://shrinklabs.com/posts/setting-up-private-kubernetes-cluster/</link>
      <pubDate>Wed, 16 Jan 2019 01:46:28 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/setting-up-private-kubernetes-cluster/</guid>
      <description>이번 과정의 실습을 진행하면서 클러스터에 대한 접근을 제한 할 수 있도록 하기 위한 방법에 대해서 알 수 있었다. 하지만 전체 내용에 대해서 정확하게 이해를 하지 못했다.
해당 내용은 이후에 비공개 클러스터 설정(https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters) 에 대한 내용이 실습 내용과 동일하므로 추후에 이해가 가능한 시점이 되면 다시 한번 시도해 보려고 한다.
아래는 내용을 이해하기 위해서 학습했던 내용들의 링크이다.
 네트워크 입문: http://kujung.tistory.com/category/%EB%98%A5%20%EC%8B%B8%EA%B8%B0/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC
 IPv4 네트워크 주소와 호스트 주소/서브넷팅/IP Class: http://itsaessak.tistory.com/174
 IP 주소체계와 클래스 구별법 (IPV4): http://korean-daeddo.</description>
    </item>
    
    <item>
      <title>7.Build Slack Bot With Node.js on Kubernetes</title>
      <link>https://shrinklabs.com/posts/build-slack-bot-with-nodejs-on-kubernetes/</link>
      <pubDate>Mon, 14 Jan 2019 13:17:21 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/build-slack-bot-with-nodejs-on-kubernetes/</guid>
      <description>이번 과정은 Secret 객체에 대해서 좀 더 자세하게 알아볼 수 있는 과정이었다.
서비스를 제공하는 프로그램(node.js 코드)을 Docker image로 만든 다음 Registry Server에 Push를 한다.
제공하는 서비스에서 외부의 서비스(slack)를 사용하기 위해서 민감한 정보인 token이 존재한다. 이 내용이 코드상 또는 image 상에 존재하지 않게 Image를 만들고자 한다.
그래서 별도로 &amp;ldquo;slack-token&amp;rdquo; 파일을 만들어서 파일을 통해서 token 정보를 제공하도록 만들어 놓았다. 해당 파일을 경로와 파일명을 포함해서 환경변수 &amp;ldquo;slack_token_path&amp;rdquo;에 등록해 놓고, 코드상에서는 환경 변수인 &amp;ldquo;slack_token_path&amp;rdquo;에 지정되어 있는 경로의 파일로 부터 token 정보를 읽어서 사용한다.</description>
    </item>
    
    <item>
      <title>6.Running Mongodb Database in Kubernetes With Statefulsets</title>
      <link>https://shrinklabs.com/posts/running-mongodb-database-in-kubernetes-with-statefulsets/</link>
      <pubDate>Fri, 11 Jan 2019 17:52:48 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/running-mongodb-database-in-kubernetes-with-statefulsets/</guid>
      <description>지금까지의 과정 중에서 가장 어려웠다.;;; 그리고 제대로 이해를 한건지도 잘 모르겠다.
일단을 이해했다고 생각되는 정도만 정리를 해봤다.
이번 과정은 StatefulSet에 대한 이해를 목표로 하고 있다.
StatefulSet에 대한 이해를 위해서는 Headless Service에 대한 이해와 StorageClass에 대한 이해가 필요했다.
StorageClass는 상태를 갖는걸 확인하기 위한 실습이 필요하다보니, Volume을 사용해야 하고 StatefulSet의 scale을 조정하게 되는 것에 따라서 Volume도 같이 조정이 되어야 해서 StorageClass 컨트롤러를 통해서 Volume을 동적으로 조정할 수 있도록 하려고 사용 된 것 같다.</description>
    </item>
    
    <item>
      <title>5.Continuous Delivery With Jenkins in Kubernetes Engine</title>
      <link>https://shrinklabs.com/posts/continuous-delivery-with-jenkins-in-kubernetes-engine/</link>
      <pubDate>Thu, 10 Jan 2019 11:40:50 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/continuous-delivery-with-jenkins-in-kubernetes-engine/</guid>
      <description>이번 과정은 Jenkins와 Kubernetes를 이용한 배포 자동화를 실습해 볼 수 있었다.
분량은 많지만 이해가 어렵지는 않은 내용이었다.
실습을 해보면서 Namespace라는 객체와 Helm이라는 패키지 관리 도구를 사용해 볼 수 있다. Namespace는 일반적으로 우리가 알고 있는 용도인데, 논리적으로 무언가를 구분지어서 사용하고 싶을때 사용하는게 목적이라고 보면 될 것 같다.
이전 과정에서 배웠던 배포를 위한 전략에서는 label을 사용했었다면, 이번에는 Namespace를 사용해서 비슷한 문제 상황을 해결하는걸 경험해 볼 수 있다.
그리고 helm은 Kubernetes의 클러스터에 올라갈 수 있도록 미리 정의해서 배포해 놓은걸 사용할 수 있게 해주는 도구였다.</description>
    </item>
    
    <item>
      <title>4.Managing Deployments Using Kubernetes</title>
      <link>https://shrinklabs.com/posts/managing-deployments-using-kubernetes/</link>
      <pubDate>Wed, 09 Jan 2019 11:15:55 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/managing-deployments-using-kubernetes/</guid>
      <description>이번 장에서는 &amp;ldquo;Deployment&amp;rdquo;가 어떤 역할을 할 수 있으며, 이를 이용해서 취할 수 있는 배포 전략에 대해서 알아볼 수 있었다.
(이번 장에서 실습을 위해서는 필수적으로 compute/zone 설정을 us-central1-a로 지정해 놓아야 cluster 생성을 정상적으로 할 수 있다.)
Deployment 뿐만이 아니라 다른 객체들을 사용하기 위해서도 yaml을 작성할때 각 필드에 대한 정보를 어디에서 확인해야 하는지가 궁금했다.
$ kubectl explain deployment $ kubectl explain --recursive $ kubectl explain deployment.metadata.name  등과 같이 확인을 할 수 있다.</description>
    </item>
    
    <item>
      <title>3.Orchestrating the Cloud With Kubernetes</title>
      <link>https://shrinklabs.com/posts/orchestrating-cloud-with-kubernetes/</link>
      <pubDate>Wed, 09 Jan 2019 01:26:47 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/orchestrating-cloud-with-kubernetes/</guid>
      <description>이번 장은 우선 &amp;ldquo;nginx&amp;rdquo;와 &amp;ldquo;monolith&amp;rdquo;라는 단어에 현혹되지 않도록 주의를 해야 할 것 같다.
최초에 nginx가 실행되는 Pod는 그거대로 Kubnernetes 작동에 대한 내용이고, Pod에 대한 내용에서 언급되는 nginx와 monolith는 또 그것대로의 내용을 설명한다.
그리고 다음에 나오는 port-forward에 대한 내용은 또 완전히 별개의 내용이다.
port-forward는 &amp;ldquo;Service&amp;rdquo;로 노출하지 않는 Pod에 대해서 테스트등을 해보기 위해서 아주 유용한 도구인 것 같다.
port-forward로 &amp;ldquo;monolith&amp;rdquo; Pod의 80 포트를 10080을 지정하면 local의 10080 포트를 사용하고 있는것 처럼 이용이 가능하다.</description>
    </item>
    
    <item>
      <title>2.Hello Node Kubernetes</title>
      <link>https://shrinklabs.com/posts/hello-node-kubernetes/</link>
      <pubDate>Tue, 08 Jan 2019 13:13:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/hello-node-kubernetes/</guid>
      <description>2번째 과정에서는 Kubernetes의 기본적인 동작 방식에 대해서 알아 볼 수 있었다.
Kubernetes의 클러스터를 생성하는 과정은 Google Cloud Platform에서 기능을 제공하고 있어서 아주 간편했다.
책을 보면서 Kubernetes 공부를 처음 시작하는 과정에서 가장 시간을 많이 소비하게 되는 부분이었는데, 플랫폼에서 제공되는 기능을 glcoud를 이용해서 node와 각 node의 기본적인 설정을 지정후 cluster를 생성하는 명령 하나로 모든 과정이 생략될 수 있게 되었다.
그리고 Registry Server에 등록해 놓았던 Image를 이용해서 직접 &amp;ldquo;Pod&amp;rdquo;를 만들어보고, &amp;ldquo;Pod&amp;rdquo;의 개념과 &amp;ldquo;Deployment&amp;rdquo;의 개념이 무엇인지에 대해서 대략적으로 알아 볼 수 있었다.</description>
    </item>
    
    <item>
      <title>1.Introduction to Docker</title>
      <link>https://shrinklabs.com/posts/introduction-to-docker/</link>
      <pubDate>Tue, 08 Jan 2019 10:48:08 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/introduction-to-docker/</guid>
      <description>구글에서 지원해주는 “2019 클라우드 스터디잼 입문반” 스터디에 참여하기 시작했다. 이 스터디는 어떠한 형태로든 모인 멤버들이 일정 기간(1&amp;frasl;7~1&amp;frasl;27) 동안에 실습이 겸해진 과정(QWIKLABS - Kubernetes in the Google Cloud)을 완수하는 방식이다.
첫번째 과정으로 “Introduction to Docker” 을 진행 했다. 다음은 과정을 진행하면서 학습할 수 있었던 내용의 요약이다.
처음 해보는 과정이라서 그런지 익숙해지기 위한 시간이 약간 필요했지만 그다지 어렵지는 않았다.
Docker의 Image와 Container 그리고 Dockerfile의 이해를 위한 몇 가지의 실습이 진행되었다. 실습들을 통해서 Image와 Container를 어떻게 구분지어서 생각해야 하는지를 학습할 수 있었다.</description>
    </item>
    
    <item>
      <title>cscope 사용(Go)</title>
      <link>https://shrinklabs.com/posts/cscope/</link>
      <pubDate>Tue, 21 Aug 2018 16:34:04 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/cscope/</guid>
      <description>Go언어 개발 환경(추가) Go언어로 작성한 코드를 분석하기 위해서 cscope가 필요할 때가 있다.
vim에서 cscope를 사용하기 위한 과정을 정리해 보려고 한다.
cscope를 설치한다. $ sudo apt-get install cscope  mkscope.sh 파일을 만든다. mkscope.sh의 내용은 다음과 같다.
이 스크립트는 https://www.cnblogs.com/shaohef/p/7358111.html 의 내용을 수정해서 사용했다.
#!/bin/bash # 기존에 존재하던 files와 out 파일을 제거한다 rm cscope.files cscope.out # $GOROOT가 존재하지 않으면 설정한다. if [&amp;quot;$GOROOT&amp;quot; = &amp;quot;&amp;quot;]; then echo &amp;quot;GOROOT is not set&amp;quot; GOROOT=`go env | grep &amp;quot;GOROOT&amp;quot; | cut -d &amp;quot;=&amp;quot; -f2` GOROOT=${GOROOT#\&amp;quot;} GOROOT=${GOROOT%\&amp;quot;} fi echo $GOROOT # Go 표준 패키지 go_src=$GOROOT/src # Go언어 표준 패키지로 제공되는 go 파일의 경로를 cscope.</description>
    </item>
    
    <item>
      <title>git push된 내용을 특정한 commit으로 되돌리기</title>
      <link>https://shrinklabs.com/posts/git-reset/</link>
      <pubDate>Tue, 31 Jul 2018 10:09:41 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/git-reset/</guid>
      <description>&amp;ldquo;iss-123&amp;rdquo; 브랜치에서 작업하던 내용을 실수로 &amp;ldquo;iss-133&amp;rdquo; 브랜치로 push 하는 어이없는 실수를 했을때 &amp;ldquo;iss-133&amp;rdquo;에 push 된 내용을 이전으로 되돌려 놓아야 한다.
git log로 이전 commit의 id를 확인한다. (ex, d50fd96d2d7e5e5cf689b0943f2b2d20d4c2dda4)
[iss-133] $ git reset --hard d50fd96d2d7e5e5cf689b0943f2b2d20d4c2dda4  이제 변경된 내용을 push 한다.
[iss-13] $ git push --force origin prj  </description>
    </item>
    
    <item>
      <title>map에 key가 존재하는지 확인</title>
      <link>https://shrinklabs.com/posts/key_exists_in_map/</link>
      <pubDate>Thu, 12 Jul 2018 16:52:08 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/key_exists_in_map/</guid>
      <description>map을 사용할때 해당하는 키가 map에 존재하는지 확인이 필요할 때가 있다.
var target[string]*item ... target[&amp;quot;apple&amp;quot;] = itm1 target[&amp;quot;orange&amp;quot;] = itm2 ... value, ok := target[&amp;quot;kiwi&amp;quot;]  </description>
    </item>
    
    <item>
      <title>Go언어 프로젝트에서 테스트 코드 작성 경험</title>
      <link>https://shrinklabs.com/posts/writing-a-unit-test/</link>
      <pubDate>Wed, 21 Feb 2018 23:02:29 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/writing-a-unit-test/</guid>
      <description>주의, 아래의 내용은 학습을 하면서 이해한 정도에서의 정리라서 틀린 내용이 많이 있을 수 있습니다. 이제 테스트 코드 작성을 시도해보기 시작하는 뉴비라서… 잘못된 부분은 지적을 해주시면 감사한 마음으로 배우겠습니다.
테스트 코드는 왜? 현재 프로젝트를 진행 중 코딩을 할 때면 계속해서 의심과 두려움이 들었다.
&amp;ldquo;내가 제대로 작성하고 있는 게 맞나?&amp;rdquo;
&amp;ldquo;이렇게 작성하면 다른 데에서 문제가 생기는 건 아닌가?&amp;rdquo;
그리고 이런 걱정들은 다음의 2가지 원인 때문이지 않을까 라고 생각하게 되었다.
첫 번째, 코드 작성 후 실행해서 결과를 확인하기 위해서 개인 개발 환경을 MessageQueue와 내가 보낸 요청에 대해 기대하는 응답을 전달해줄 MessageQueue 반대편의 모듈을 구성하기가 쉽지 않다는 것이었다.</description>
    </item>
    
    <item>
      <title>KVM 스터디(with go)</title>
      <link>https://shrinklabs.com/posts/kvm-with-go/</link>
      <pubDate>Sat, 02 Dec 2017 23:55:52 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/kvm-with-go/</guid>
      <description>주의, 이 글은 KVM이 뭔지도 제대로 모르면서 학습한 내용을 정리한거라서, 정확하지 않은 내용이 다수 포함되어 있을 수 있습니다.
틀린 내용은 지적해 주시면 수정해서 반영하도록 하겠습니다.
준비물 노트북(우분투 16.04)
KVM이 뭔가요? 하이퍼바이저? 위키백과에 나와 있는 정의( https://ko.wikipedia.org/wiki/%ED%95%98%EC%9D%B4%ED%8D%BC%EB%B0%94%EC%9D%B4%EC%A0%80 ) 를 보면 이렇게 나와 있다.
&amp;ldquo;다수의 운영 체제를 동시에 실행하기 위한 논리적 플랫폼&amp;rdquo;
여기에 우리가 잘 알고 있는 VmWare, VirtualBox와 같은것도 있고, Xen, KVM 같이 좀 낯선 것들도 있다.
내용을 읽다보면, 왠지 중요해 보이는 단어 Type1, Type2, 전가상화, 반가상화 뭐 이런 단어들이 나온다.</description>
    </item>
    
    <item>
      <title>core파일 만들기</title>
      <link>https://shrinklabs.com/posts/core/</link>
      <pubDate>Tue, 01 Aug 2017 13:59:57 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/core/</guid>
      <description>Go언어에서도 core dump를 떨구는 방법이 있었다.
데이브체니님이 정리해 놓은 무려 2015년도의 글이다.
https://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables
환경변수로 GOTRACEBACK 을 crash로 설정만 해주면 된다.
이런것도 모르고 Go언어에서는 dump를 생성할 수 없다고 말하고 다녔다&amp;hellip;;
근데 위에 처럼 환경변수 설정하고도 core 파일이 안생긴다면, 다음 블로그의 글을 참고해 보면 좋을것 같다.
http://lapan.tistory.com/68
블로그의 내용처럼 ulimit -a 로 확인 해보니 core file size가 0으로 되어 있다.
ulimit -c unlimited 로 해주었다.
이제 panic을 발생시켜 보면 core 파일이 잘 만들어져 있는걸 확인 할 수 있다.</description>
    </item>
    
    <item>
      <title>docker 시작하기</title>
      <link>https://shrinklabs.com/posts/docker/</link>
      <pubDate>Thu, 27 Jul 2017 00:25:51 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/docker/</guid>
      <description>docker ce 설치  오래된 버전 제거
$ sudo apt-get remove docker docker-engine docker.io  패키지 인덱스 업데이트
$ sudo apt-get update  apt가 https를 통해서 저장소를 사용할 수 있도록 패키지를 설치
$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common  docker의 공식 GPG 키를 추가
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -  fingerprint를 확인
$ sudo apt-key fingerprint 0EBFCD88  안정화 버전의 저장소를 추가</description>
    </item>
    
    <item>
      <title>delve를 사용한 Go언어 디버깅</title>
      <link>https://shrinklabs.com/posts/delve/</link>
      <pubDate>Sun, 18 Jun 2017 23:13:14 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/delve/</guid>
      <description>소개 delve는 Go언어를 위한 debugger 이다.
delve설치 설치를 하기위해서는 Go 1.5 이상의 버전이 필요하다.
지금 시점에 Go 1.5를 사용하지 않을테니&amp;hellip;
다음의 명령으로 설치한다.
$ go get github.com/derekparker/delve/cmd/dlv  이제 설치 끝! (Windows랑 MAC은 모르겠다.)
delve사용 프로세스 실행 제어, 변수, 스레드/goroutine 상태, CPU 레지스터 상태 등을 확인 할 수 있다.
 Commands
 attach: 실행중인 프로세스에 연결해서 디버깅을 한다.
$ dlv attach pid [executable]  실행중인 프로세스에 디버그 세션을 연결해서 프로세스를 제어한다.</description>
    </item>
    
    <item>
      <title>build</title>
      <link>https://shrinklabs.com/posts/build/</link>
      <pubDate>Thu, 25 May 2017 15:43:40 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/build/</guid>
      <description>소개 Go언어로 개발을 하다보면 debug모드 release모드 같이 별도의 빌드 환경을 구성하고 싶을때가 있다.
그래서 build 옵션으로 특정한 환경별로 결과를 달리 할 수 있는 방법에 대해서 테스트한 내용을 정리해본다.
빌드 go 파일들을 빌드하기 위해서는 일반적으로 다음과 같이 한다.
$ go build  Go언어 문서중에 보면 https://golang.org/pkg/go/build/#hdr-Build_Constraints[Build Constraints] 에 관한 내용이 있다.
이 내용은 build 할 때 조건을 줄 수 있다는 내용이고 방법은 다음과 같이 하면 된다고 한다.
코드의 상단에 &amp;ldquo;// +build linux&amp;rdquo; 하고 한 칸을 띄우고 &amp;ldquo;package blah&amp;rdquo; 를 시작한다.</description>
    </item>
    
    <item>
      <title>RabbitMQ 스터디(with go)</title>
      <link>https://shrinklabs.com/posts/rabbitmqwithgo/</link>
      <pubDate>Wed, 19 Apr 2017 23:43:52 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/rabbitmqwithgo/</guid>
      <description>Go언어로 RabbitMQ를 어떻게 이용할 수 있는지 스터디하는 내용들을 대충 대충 정리하는 중&amp;hellip;
RabbitMQ라는게 뭐지? AMQP를 구현한 메세지 브로커
여기 저기에 있는 클라이언트들(Producer/Consumer)이 메세지를 서로 주고 받을 수 있도록 해주는 그런거?
설치  RabbitMQ 설치
sudo apt-get install rabbitmq-server  관리 플러그인 설치
sudo rabbitmq-plugins enable rabbitmq_management sudo service rabbitmq-server restart  실행
service rabbitmq-server start  계정 등록(id:shrinklabs, pw:1234)
rabbimqctl add_user shrinklabs 1234  등록한 계정을 관리자 계정으로 변경</description>
    </item>
    
    <item>
      <title>CreateFormFile()을 사용하면 Content-Type이 고정되는 현상</title>
      <link>https://shrinklabs.com/posts/multipart-contenttype/</link>
      <pubDate>Sat, 10 Dec 2016 18:22:48 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/multipart-contenttype/</guid>
      <description>mime/multipart를 사용해서 파일을 업로드 하려 할때 파일을 업로드할 필드를 생성하기 위해서 CreateFormFile()을 사용한다.
이를 이용해서 파일을 업로드하면 &amp;ldquo;Content-Type&amp;rdquo;이 &amp;ldquo;application/octet-stream&amp;rdquo; 으로 고정되어진다.
src/mime/multipart/writer.go의 CreateFormFile을 확인해 보면 다음과 같이 고정되어 있는걸 확인 할 수 있다.
h.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/octet-stream&amp;quot;)  관련한 이슈가 올라온게 혹시 있지 않을까 해서 찾아보니.
이런 이슈가 있었다.
https://github.com/golang/go/issues/16425
bradfitz는 다음과 같이 답변을 하고 있다.
 Use CreatePart. CreateFormFile is a very thin wrapper around CreatePart. Click https://golang.org/pkg/mime/multipart/#Writer.CreateFormField[] and then click the CreateFormFile heading to see its source code.</description>
    </item>
    
    <item>
      <title>Go코드로 HTML Form 전송</title>
      <link>https://shrinklabs.com/posts/html-form/</link>
      <pubDate>Tue, 06 Dec 2016 01:13:41 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/html-form/</guid>
      <description>HTML, Javascript를 사용해서 Post방식으로 Form을 전송하는 동작을 Go 코드를 작성해 보자.
우선 POST로 전송된 Form을 받아서 처리를 하는 서버쪽을 다음과 같은 구성을 갖는 코드로 만든다.
package main import { &amp;quot;net/http&amp;quot; &amp;quot;github.com/gorilla/mux&amp;quot; } func main() { r := mux.Newrouter().StrictSlash(false) r.HandleFunc(&amp;quot;/upload&amp;quot;, upload).Methods(&amp;quot;POST&amp;quot;) http.ListenAndServe(&amp;quot;:8080&amp;quot;, r) } func upload(w http.ResponseWriter, r *http.Request) { if r.Method == &amp;quot;POST&amp;quot; { } }  이렇게 &amp;ldquo;http://localhost:8080/upload&amp;quot; 를 통해서 POST 방식으로 전달되는 요청을 받아서 처리하기 위한 큰틀을 만들었다.</description>
    </item>
    
    <item>
      <title>인코딩된 텍스트 디코딩하기</title>
      <link>https://shrinklabs.com/posts/encode-go/</link>
      <pubDate>Fri, 25 Nov 2016 00:52:47 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/encode-go/</guid>
      <description>Javascript에서 encodeURIComponent() 함수를 사용해서 전달받은 문자열을 디코딩해서 보기 위해서는 &amp;ldquo;net/url&amp;rdquo; 패키지의 QueryUnescape() 함수를 사용할 수 있다.
email, err := url.QueryUnescape(user.Email)  </description>
    </item>
    
    <item>
      <title>vendor 관리</title>
      <link>https://shrinklabs.com/posts/govendor/</link>
      <pubDate>Fri, 14 Oct 2016 18:16:35 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/govendor/</guid>
      <description>vendoring되어 있는 패키지를 관리해야 할 이유가 무엇인지에 대해서 찾아보다가 좋은 글을 발견했다.
https://gocodecloud.com/blog/2016/03/29/go-vendoring-beginner-tutorial/
이 글을 읽고 이해한 정도만을 요약
vendoring을 왜 하나? Project A에서 사용하는 Pkg X의 리비전 1을 사용하고 있다. 그런데 Project B에서는 Pkg X의 리비전 2를 사용하려 한다.
그런데 $GOPATH 안에는 같은 패키지를 하나만 갖고 있을 수 있다.
Pkg X의 리비전을 Project A에 맞추면 Project B가 빌드를 실패하고, Project B에 맞추면 Project A가 빌드에 실패하게 된다.
그래서 패키지들을 vendor 아래에 위치 시킨다.</description>
    </item>
    
    <item>
      <title>GitHub 페이지에 Hugo 올리기</title>
      <link>https://shrinklabs.com/posts/hugo/</link>
      <pubDate>Thu, 13 Oct 2016 14:17:19 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/hugo/</guid>
      <description>Blogger에서 Hugo( http://gohugo.io )로 갈아타는 과정을 정리해 본다.
Hugo 를 설치한다 https://github.com/spf13/hugo/releases 에서 본인의 환경에 맞는걸 찾아서 설치한다.
Linux는 deb를 제공하고 있지만, Windows는 exe파일을 제공하고 있어서 환경변수(PATH)를 잡아주던가, 환경변수가 잡혀있는곳에 복사를 해준다.
(이름도 hugo.exe로 바꿔주는게 사용하기에 더 편리한것 같다.)
MAC은 안 써봐서 잘 모르겠다&amp;hellip;;;;
github에 저장소를 만든다 github에서 호스팅을 받아서 hugo를 사용하기 위해서는 2개의 저장소를 만들어야 한다.
hugo의 컨텐츠를 관리하기 위한 저장소가 필요하다.(ex: https://github.com/shrinklabs/blog)
그리고 컨텐츠를 보여주기 위한 github의 페이지 저장소(ex: https://github.</description>
    </item>
    
    <item>
      <title>tmux</title>
      <link>https://shrinklabs.com/posts/tmux/</link>
      <pubDate>Wed, 12 Oct 2016 01:28:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/tmux/</guid>
      <description>tmux 시작 $ tmux $ tmux new-session(or new) -s [세션 이름] -n [윈도우 이름]  tmux 종료 $ ctrl-d $ exit  tmux detach(현재 클라이언트) $ ctrl-b, d  tmux attach $ tmux attach -t [세션 이름]  window 생성 $ ctrl-b, c  window 리스트 $ ctrl-b, w  window 이동(현재의 이전(다음, 이전) $ ctrl-b, l(n, p)  window 종료 $ ctrl-b, &amp;amp;  window 이름 변경 $ ctrl-b, ,  pane 가로 나누기 $ ctrl-b, %  pane 세로 나누기 $ ctrl-b, &amp;quot;  pane 의 번호를 화면에 출력 $ ctrl-b, q  pane 크기 조절 $ ctrl-b, (ctrl + 방향키)  모든 pane의 크기 동일하게 만들기 $ ctrl-b alt-1 # 모든 vertical split 넓이를 동일하게 변경 $ ctrl-b alt-2 # 모든 horizontal split의 넓이를 동일하게 변경  pane 이동하기 $ ctrl-b, o  pane 이동하기 $ ctrl-b, 방향키 $ ctrl-b {(})  pane 삭제하기 $ ctrl-d  pane 화면 스크롤 모드 시작 $ ctrl-b, [  pane 화면 스크롤 모드 종료 $ q  입력되는 내용을 모든 pane에 동일하게 적용 $ ctrl-b : setw synchronize-panes  http://nodeqa.</description>
    </item>
    
    <item>
      <title>vi 팁</title>
      <link>https://shrinklabs.com/posts/vi/</link>
      <pubDate>Mon, 05 Sep 2016 01:28:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/vi/</guid>
      <description>현재 작업중인 파일의 경로와 이름 확인 현재 작업중인 파일의 경로 또는 이름이 궁금할 경우가 있다.
ctrl + g  또는
: f  80컬럼에 버티컬 라인 vi에서 80컬럼의 버티컬 라인을 생성하려면 다음과 같이 한다.
set colorcolumn=80  을 적용하면, 빨간색 라인이 생긴다.
파일 관리 NerdTree를 사용하지 않고 vi에서 파일과 디렉토리를 관리하는 방법
파일 네비게이션
 표준모드(ex: i, o, a 같은걸 입력해서 입력모드로 전환되기 전 상태)
 &amp;ldquo;e.&amp;rdquo; (설명: &amp;ldquo;.&amp;rdquo; 는 현재의 디렉토리)</description>
    </item>
    
    <item>
      <title>vim-go 기본 템플릿 비활성화</title>
      <link>https://shrinklabs.com/posts/vim-go/</link>
      <pubDate>Mon, 05 Sep 2016 01:28:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/vim-go/</guid>
      <description>vim-go가 언제부터인가 main.go 를 만들면 템플릿으로 fmt.Println(&amp;ldquo;vim-go&amp;rdquo;) 를 찍어주는 코드를 자동으로 생성해 주기 시작했다.
나는 아무것도 나오지 않기를 바랬는데, 이런게 나와서 매번 지우는 작업을 하는게 싫었다. 그래서 설정중에 go_template_autocreate 를 조절했다.
let g:go_template_autocreate = 0  와 같이 하면 이제 아무것도 없는 빈 화면이 나온다.
혹시라도 반복적으로 나오는게 좋은데 &amp;ldquo;vim-go&amp;rdquo;를 찍는게 아닌 특정한 코드가 필요하다면, &amp;ldquo;.vim/bundle/vim-go/templates/hello_world.go&amp;rdquo; 파일을 수정해도 된다. 또는 특정한 템플릿을 지정하고 싶다면, 다음과 같이,
let g:go_template_file = &amp;quot;hello_world.go&amp;quot;  로 해도 된다.</description>
    </item>
    
    <item>
      <title>template을 생성할때 왜 이름을 지정할까?</title>
      <link>https://shrinklabs.com/posts/template/</link>
      <pubDate>Sat, 03 Sep 2016 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/template/</guid>
      <description>Go언어의 Template 엔진을 사용할때, 왜 New()의 파라미터로 이름을 만들어서 넘겨야 하는지가 궁금했었다.
Template and Associated templates라는 글을 읽고 어느 정도 이해를 하게 되었다.
다음은 위 글의 내용을 요약한 것이다.
template.New() 로 template을 만들때, 이름을 정해서 만든다.
이 때 FuncMap과 템플릿 리스트를 갖는 그룹(그룹의 이 글에서 사용하는 용어로 Associated Templates를 가르킨다)이 생성된다.
FuncMap에 대해서는,
https://golang.org/pkg/html/template/#FuncMap
http://goinbigdata.com/example-of-using-templates-in-golang/
http://technosophos.com/2013/11/23/using-custom-template-functions-in-go.html
를 확인해본다.
New()를 했어도 아직 템플릿 리스트에서 관리되는 대상은 아니다.
Parse(&amp;hellip;)를 하면 템플릿 리스트에 추가가 된다.</description>
    </item>
    
    <item>
      <title>ifconfig 사용</title>
      <link>https://shrinklabs.com/posts/ifconfig/</link>
      <pubDate>Thu, 21 Jul 2016 01:28:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/ifconfig/</guid>
      <description>임시로 사용할 개발환경을 만들기 위해서 ubuntu 이미지를 사용하는데,
ifconfig 명령이 동작하지 않아서 보니, net-tools가 온전하게 설치되었지가 않은것 같다.
$ apt-get install --reinstall net-tools  </description>
    </item>
    
    <item>
      <title>css와 같은 정적 컨텐츠를 html에서 사용하기 위한 팁</title>
      <link>https://shrinklabs.com/posts/css-html/</link>
      <pubDate>Mon, 18 Jul 2016 10:16:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/css-html/</guid>
      <description>Go의 &amp;ldquo;net/http&amp;rdquo;와 &amp;ldquo;html/template&amp;rdquo;를 이용해서 html과 css로 만들어진 웹페이지를 만들려고 할때, html 파일이 보여질때 css가 적용되지 않은 상태로 보여진다.
이 때 어떻게 해야 하는지 방법을 찾아가던 과정을 기록으로 남겨 놓는다.
프로젝트의 디렉토리 구조는 다음과 같다.
src\ + prj + main.go + static style.css + template index.html  그래서 이렇게&amp;hellip;
func main() { http.HandleFunc(&amp;quot;/&amp;quot;, indexHandler) http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil) } func indexHandler(...) { // index.html }  와 같이 하면 될 줄 알았다.
그런데 안된다.</description>
    </item>
    
    <item>
      <title>http 패키지의 HandleFunc과 Handle</title>
      <link>https://shrinklabs.com/posts/http-handlefunc-handle/</link>
      <pubDate>Sun, 17 Jul 2016 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/http-handlefunc-handle/</guid>
      <description>HandleFunc  http.ResponseWriter 와 *http.Request를 인자로 받는 함수를 전달받는다. 내부적으로 ServeHTTP가 구현된 ServeMux를 사용한다.
package main import ( &amp;quot;net/http&amp;quot; ) func indexHandler(w http.ResponseWriter, r *http.Request) { .... } func main() { http.HandleFunc(&amp;quot;/&amp;quot;, indexHandler) http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil) }   Handle  http.Handler 인터페이스를 구현한 객체를 전달받는다. 인자로 전달받은 객체는 http.Handler의 ServeHTTP(http.ResponseWriter, *http.Request)가 구현되어 있어야 한다.
package main import ( &amp;quot;net/http&amp;quot; ) type indexHandler struct { } func (index *AppHandler) ServeHTTP(w http.</description>
    </item>
    
    <item>
      <title>zsh(oh-my-zsh) 사용</title>
      <link>https://shrinklabs.com/posts/zsh/</link>
      <pubDate>Thu, 21 Apr 2016 14:39:36 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/zsh/</guid>
      <description>zsh 설치하고 기본 쉘 변경 $ sudo apt-get install zsh $ which zsh /usr/bin/zsh $ chsh -s /usr/bin/zsh  oh-my-zsh 설치 $ curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh  설정(개인 취향) .zshrc 의 ZSH_THEME를 minimal 로 변경</description>
    </item>
    
    <item>
      <title>terminator 사용</title>
      <link>https://shrinklabs.com/posts/terminator/</link>
      <pubDate>Thu, 21 Apr 2016 13:35:10 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/terminator/</guid>
      <description> 설치 $sudo apt-get install terminator  단축키 분할(수직): ctrl + shift + e 분할(수평): ctrl + shift + o 닫기(현재 창): ctrl + shift + w 닫기(전체): ctrl + shift + q 새 탭: ctrl + shift + t 분할된 화면간 이동: alt + 방향키  </description>
    </item>
    
    <item>
      <title>vendor 사용 팁(내부 패키지)</title>
      <link>https://shrinklabs.com/posts/vendor/</link>
      <pubDate>Wed, 09 Mar 2016 14:12:58 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/vendor/</guid>
      <description>프로젝트 내부에서 별도의 패키지를 만들어서 사용을 하려고 할때면,
import 경로를 &amp;ldquo;github.com/blah/project/internalpkg&amp;rdquo; 처럼 다 써야 했었다.
이제 vendor를 사용하면 pkg 이름만 import 해서 사용할 수 있게 되었다.
샘플 프로젝트는 다음과 같다.
https://github.com/shrinklabs/lotto
샘플 프로젝트에 대해서 약간의 설명을 더하면,
기존에는 command 패키지를 commands.go 에서 import 하기 위해서,
import &amp;ldquo;github.com/shrinklabs/lotto/command&amp;rdquo; 와 같이 사용해야 했었다.
이렇게 되면 lotto 프로젝트를 다른 사람이 fork 해서 사용하려고 하면 일일이 import 경로를 변경해줘야 하는 문제가 생기게 된다.
그래서 go1.</description>
    </item>
    
    <item>
      <title>pkg 원격저장소 연결하기</title>
      <link>https://shrinklabs.com/posts/meta-tag-pkg-repository/</link>
      <pubDate>Thu, 11 Jun 2015 13:43:41 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/meta-tag-pkg-repository/</guid>
      <description>최근에 go소스들을 분석하면서 특이한 pkg import 경로들을 보게되었다.
import &amp;quot;rsc.io/pdf&amp;quot;  와 같은 &amp;ldquo;github.com/rsc/pdf&amp;rdquo; 와 동일한 내용인데 그리고 rsc는 russ cox가 사용하는 닉네임인데&amp;hellip;그럼 같은 pkg인가?
그래서 웹브라우저에서 rsc.io/pdf 를 입력하면 godoc로 이동을 하네?
어떻게 한걸까!? 궁금했다. 그리고 왠지 멋있어 보였다&amp;hellip;;
그러다가 우연히 rob pike의 github page(https://github.com/robpike/robpike.github.io)를 보게 되었다.
index.html 에 이렇게만 코드가 되어 있었다.
&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;robpike.io/cmd hg https://code.google.com/p/rspace.cmd&amp;quot;&amp;gt; This is a git repository holding a redirect for the Go repositories referenced by robpike.</description>
    </item>
    
    <item>
      <title>개발환경 설정</title>
      <link>https://shrinklabs.com/posts/setting/</link>
      <pubDate>Sat, 23 May 2015 01:28:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/setting/</guid>
      <description>업데이트 $ sudo apt-get update $ sudo apt-get install build-essential  vim 설치 $ sudo apt-get install vim  vim 8.0 $ sudo add-apt-repository ppa:jonathonf/vim $ sudo apt-get update  xclip 설치 $ sudo apt-get install xclip  wget 설치(사용이 필요한 경우에만 설치) $ sudo apt-get install wget  git 설치  git 설치와 설정
$ sudo apt-get install git $ git config –-global user.name “blah” $ git config –-global user.</description>
    </item>
    
    <item>
      <title>pkg-config 사용</title>
      <link>https://shrinklabs.com/posts/pkg-config/</link>
      <pubDate>Fri, 06 Mar 2015 01:28:09 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/pkg-config/</guid>
      <description>Go언어를 사용하다보면 C로 만들어진 라이브러리를 사용하기 위해서 cgo가 필요할 때 가 있다. 라이브러리를 링크하고 하는 몇 가지 절차를 거치게 되는데, 이때 pkg-config라는걸 사용하면 편리하다.
pkg-config를 사용하면 컴파일하는데 필요한 라이브러리와 헤더정보를 Go코드상에서 동일한 경로로 제공해줄 수 있게 된다.
pkg-config가 설치되어 있지 않을 경우에는 다음과 같이 설치를 해준다.
$ sudo apt-get install pkg-config  이제 설치되어 있는 라이브러리 목록을 한번 보자.
$ pkg-config --list-all  현재 설치된 라이브러리들의 정보가 나오게 된다.
그런데 내가 원하는 라이브러리의 정보가 나타나지 않는다.</description>
    </item>
    
    <item>
      <title>Golang channels tutorial</title>
      <link>https://shrinklabs.com/posts/golang-channels-tutorial/</link>
      <pubDate>Wed, 10 Dec 2014 13:12:58 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/golang-channels-tutorial/</guid>
      <description>최근에 goroutine과 channel에 대해서 학습하다가 설명이 잘 되어 있는 글을 찾아서 번역(이라고 하기에는 뭐하고 정리?) 를 해봤다. 제대로 이해를 못하고 잘 못 번역을 한 부분이 있을 수 도 있으니&amp;hellip;꼭 원본을 보길 권장한다.;;;
원본 : http://guzalexander.com/2013/12/06/golang-channels-tutorial.html
Go언어는 병렬 프로그램 작성을 위해서 내장 도구를 갖고 있다. go를 함수 호출 앞에 놓으면 동일한 주소에 위치하는 코드를 독립적인 병렬 스레드로 실행을 시작한다. 이런 쓰레드를 Go언어에서는 goroutine이라고 부른다. 여기에서 말하는 concurrently는 parallel을 의미하지는 않는다. (역주: 그렇지만 번역은 “병렬” 이라고 칭하겠다.</description>
    </item>
    
    <item>
      <title>md5 패키지 사용예</title>
      <link>https://shrinklabs.com/posts/md5/</link>
      <pubDate>Tue, 08 Oct 2013 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/md5/</guid>
      <description>Qt로 만드는 클라이언트에서 이미지 파일에 대해서 만들어진 md5 hash를 검증 해보기 위해서, 같은 이미지 파일에 대해서 Go언어로 md5 hash를 만들었을때 동일한 값이 생성되면 제대로 만들어진거 아닐까 해서, 만들어 봄.
(사실은 일하기 싫어서 괜히 한번 해 본&amp;hellip;)
package main import ( &amp;quot;io/ioutil&amp;quot; &amp;quot;crypto/md5&amp;quot; &amp;quot;fmt&amp;quot; ) func main() { data, err := ioutil.ReadFile(&amp;quot;1.jpg&amp;quot;) if err != nil { return; } hash := md5.New() hash.Write(data) hashData := hash.Sum(nil) fmt.Printf(&amp;quot;%x&amp;quot;, hashData) }  </description>
    </item>
    
    <item>
      <title>C언어의 배열을 Go언어의 slices로 변환</title>
      <link>https://shrinklabs.com/posts/c-go-slices/</link>
      <pubDate>Tue, 17 Sep 2013 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/c-go-slices/</guid>
      <description>cgo를 이용하다보면, C언어로 작성된 라이브러리의 리턴값으로 포인터에 구조체가 할당되어서 넘어올때가 있다.
C언어에서 넘어오는 구조체 배열이 포인터 형태로 넘어오니, Go의 포인터에 할당을 해서 사용 해봤다.
당연히 제대로 동작하지 않는다. C언어로 작성된 라이브러리에서 넘어오는 값은 배열이니, Go언어에서는 slices에 할당을 하는게 맞는것 같다.
다음의 내용을 보면, array를 어떻게 slices에 할당을 해야 할지에 대해서 잘 설명이 되어 있다.
&amp;ldquo;Turning C arrays into Go slcies&amp;rdquo; ( https://code.google.com/p/go-wiki/wiki/cgo )
아래는 cubrid driver를 만들면서 사용한 코드이다.
slcieHeader := (*reflect.</description>
    </item>
    
    <item>
      <title>type으로 이름 붙여진 구조체의 필드를 사용하기위한 방법</title>
      <link>https://shrinklabs.com/posts/cgo-type/</link>
      <pubDate>Tue, 03 Sep 2013 17:10:53 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/cgo-type/</guid>
      <description>c로 만들어져 있던 라이브러리를 cgo를 이용해서 포팅(?)을 하는 작업을 하다보면 난감한 부분들이 종종 나타난다.
그중에 한가지가 c에서 사용하던 구조체의 파라미터명이 go 에서 미리정의된 명칭일 경우가 있다.
대표적인 예로 &amp;ldquo;type&amp;rdquo;이라는 파라미터명이다.
c에서는 T_CCI_COL_INFO(cubrid의 cci에서 사용되는 구조체중에 하나) 의 필드중에 하나가 type이라는 필드가 하나 있다.
이걸 go에서 사용을 하려고 하니,,,
&amp;rdquo;&amp;hellip;expected selector or type assertion, found &amp;lsquo;type&amp;rsquo; &amp;ldquo; 이라는 결과를 만나게 된다.
이걸 도대체 어떻게 사용해야 하나 고민을 하던중, golang.org 에 있는 문서 http://golang.</description>
    </item>
    
    <item>
      <title>패키지 만들때 testing 패키지 사용하기</title>
      <link>https://shrinklabs.com/posts/testing/</link>
      <pubDate>Fri, 23 Aug 2013 14:12:58 +0900</pubDate>
      
      <guid>https://shrinklabs.com/posts/testing/</guid>
      <description>개요 Go 언어용 패키지를 만들려면, 테스트코드를 해야 개발이 진행이 좀 더 원활하게 되는 것 같다.
그래서 간단하게 테스트 코드 작성하는 방법을 정리해봤다.
abc 패키지를 만들어서 테스트하기 src\abc\abc.go
src\abc\abc_test.go 와 같이 파일을 만들어 놓는다.
abc.go를 다음과 같이 작성한다.
// abc.go package abc import ( &amp;quot;fmt&amp;quot; ) func A_Method() { fmt.Println(&amp;quot;test A Method&amp;quot;) }  그리고 abc_test.go를 다음과 같이 작성한다.
// abc_test.go package abc import ( &amp;quot;testing&amp;quot; ) func TestA_Method(t *testing.T) { A_Method() }  그리고 $GOPATH/src/abc/ 에서</description>
    </item>
    
    <item>
      <title></title>
      <link>https://shrinklabs.com/posts/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shrinklabs.com/posts/test/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://shrinklabs.com/posts/test2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shrinklabs.com/posts/test2/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>