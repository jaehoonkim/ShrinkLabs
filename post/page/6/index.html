<!DOCTYPE html>
<html lang="en">
  <head>
  	<meta charset="utf-8">
  	<meta name="viewport"    content="width=device-width, initial-scale=1.0">
  	<meta name="description" content="">
  	<meta name="author"      content="map[]">
    
    	<title>Posts</title>
    
    <script data-ad-client="ca-pub-8444244371421612" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


	<link rel="shortcut icon" href="https://shrinklabs.com/images/favicon.ico">

	
	<link href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css" rel="stylesheet">
	
	
	<script defer src="https://use.fontawesome.com/releases/v5.0.11/js/all.js" integrity="sha384-ImVoB8Er8knetgQakxuBS4G3RSkyD8IZVVQCAnmRJrDwqJFYUE4YOv+DbIofcO9C" crossorigin="anonymous"></script>
	
	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Alice|Open+Sans:400,300,700">
	
	
  
  <link rel="stylesheet" href="https://shrinklabs.com/css/styles.min.16be9015b1d15d94201894c956885e507505d7b2f836db72cf9bb664b89c63ac6f9b7de5b6d4671478edb138a9c227c4c4e6619e22ef55bd586fa93fb6eed058.css" integrity="sha512-Fr6QFbHRXZQgGJTJVoheUHUF17L4Nttyz5u2ZLicY6xvm33lttRnFHjtsTipwifExOZhniLvVb1Yb6k/tu7QWA==">

   
  

  </head>
  
  <body class="home">

    
      <header id="header">
  <div id="head" class="parallax" data-parallax-speed="2" style="background-image:url('https://shrinklabs.com/images/bg_head.jpg');">
    <h1 id="logo" class="text-center">
      <img class='img-circle' src="https://shrinklabs.com/images/logo.png" alt="">
      <span class="title"></span>
      <span class="tagline"><br>
        <a href="mailto:"></a>
      </span>
   </h1>
</div>

<nav class="navbar navbar-default navbar-sticky">
    <div class="container-fluid">

        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="true">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>

        <div class="navbar-collapse collapse" id="bs-example-navbar-collapse-1">

            <ul class="nav navbar-nav">
            
                
                <li>
                    <a href="/">home</a>
                </li>
                
            
                
                <li>
                    <a href="/post/">blog</a>
                </li>
                
            
            </ul>

        </div> 
        
    </div>
</nav>

</header>
    
 
    
<main id="main">

	<div class="container">
		<div class="row topspace">
			<div class="col-sm-8 col-sm-offset-2">

        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="May 23, 2015">May 23, 2015</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/tool_setting/" rel="bookmark">개발환경 설정</a>
						</h1>
					</header>
					<div class="entry-content">
						<h2 id="업데이트">업데이트</h2>
<pre><code>$ sudo apt-get update  
$ sudo apt-get install build-essential
</code></pre><h2 id="vim-설치">vim 설치</h2>
<pre><code>$ sudo apt-get install vim
</code></pre><h2 id="vim-80">vim 8.0</h2>
<pre><code>$ sudo add-apt-repository ppa:jonathonf/vim  
$ sudo apt-get update
</code></pre><h2 id="xclip-설치">xclip 설치</h2>
<pre><code>$ sudo apt-get install xclip
</code></pre><h2 id="wget-설치사용이-필요한-경우에만-설치">wget 설치(사용이 필요한 경우에만 설치)</h2>
<pre><code>$ sudo apt-get install wget
</code></pre><h2 id="git-설치">git 설치</h2>
<ol>
<li>git 설치와 설정</li>
</ol>
<pre><code>$ sudo apt-get install git  
$ git config –-global user.name “blah”  
$ git config –-global user.email “blah@blah.com”  
$ git config --global core.editor vim  
$ git config --global core.commentchar &quot;*&quot;  
$ ssh-keygen -t rsa -C “blah@blah.com”  
$ xclip -sel clip &lt; ~/.ssh/id_rsa.pub
</code></pre><ol start="2">
<li>github/bitbucket에 ssh key 값을 등록</li>
</ol>
<h2 id="gopath로-사용할-위치-생성">GOPATH로 사용할 위치 생성</h2>
<pre><code>$HOME/work  
bin  
pkg  
src
</code></pre><h2 id="go-설치">Go 설치</h2>
<ol>
<li>기존에 설치된 버전이 있다면 삭제합니다.</li>
</ol>
<pre><code>$ rm -r /usr/local/go
</code></pre><ol start="2">
<li><a href="http://golang.org/doc/install">http://golang.org/doc/install</a> 에서 다운로드<br>
(또는$ wget &ndash;no-check-certificate <a href="https://storage.googleapis.com/golang/go1.7.1.linux-amd64.tar.gz">https://storage.googleapis.com/golang/go1.7.1.linux-amd64.tar.gz</a> 와 같이 원하는 OS 및 버전에 맞는 Go 바이너리를 wget으로 받을 수도 있습니다.)</li>
<li>/usr/loca/go에 압축을 풉니다.</li>
</ol>
<pre><code>$ sudo tar -C /usr/local -xzf gox.x.x.linux-xxx.tar.gz
</code></pre><ol start="4">
<li>$HOME/.profile 에 다음을 추가합니다.</li>
</ol>
<pre><code>export PATH=$PATH:/usr/local/go/bin  
export GOPATH=$HOME/work
</code></pre><p>추가) app engine도 사용 할 경우에는 PATH에 app engine의 위치도 추가</p>
<ol start="5">
<li>적용</li>
</ol>
<pre><code>$ source ~/.profile
</code></pre><h2 id="ctags-설치">ctags 설치</h2>
<ol>
<li>설치</li>
</ol>
<pre><code>$ sudo apt-get install ctags
</code></pre><ol start="2">
<li>go가 설치된 위치로 이동(/usr/local/go)해서 tag 생성</li>
</ol>
<pre><code>$ sudo ctags -R
</code></pre><ol start="3">
<li>vimrc 파일에 다음을 추가합니다.</li>
</ol>
<pre><code>set tags +=/usr/local/go/tags
</code></pre><h2 id="python과-cmake-설치">python과 cmake 설치</h2>
<ul>
<li>YouCompleteMe라는 vim 플러그인의 정상적인 설치를 위해서 python과 cmake를 설치합니다.
<pre><code>$ sudo apt-get install python-dev python3-dev  
$ sudo apt-get install cmake
</code></pre></li>
</ul>
<h2 id="vundlevim을-이용한-nerdtree와-fatihvim-go-설치">Vundle.vim을 이용한 NERDTree와 fatih/vim-go 설치</h2>
<ul>
<li>Vundle.vim 설치
<pre><code>$ git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim
</code></pre></li>
<li>/etc/vim/vimrc.local 을 생성해서 아래의 내용을 붙여 넣습니다.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Shell" data-lang="Shell">set nocompatible <span style="color:#e6db74">&#34; be iMproved, required
</span><span style="color:#e6db74">filetype off &#34;</span> required

set autoindent
set smartindent
set shiftwidth<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>
set number
set expandtab
set tabstop<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>

<span style="color:#e6db74">&#34; set the runtime path to include Vundle and initialize
</span><span style="color:#e6db74">set rtp+=~/.vim/bundle/Vundle.vim
</span><span style="color:#e6db74">call vundle#begin()
</span><span style="color:#e6db74">&#34;</span> alternatively, pass a path where Vundle should install plugins
<span style="color:#e6db74">&#34;call vundle#begin(&#39;~/some/path/here&#39;)
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">&#34;</span> let Vundle manage Vundle, required
Plugin <span style="color:#e6db74">&#39;gmarik/Vundle.vim&#39;</span>

<span style="color:#e6db74">&#34; The following are examples of different formats supported.
</span><span style="color:#e6db74">&#34;</span> Keep Plugin commands between vundle#begin/end.
<span style="color:#e6db74">&#34; plugin on GitHub repo
</span><span style="color:#e6db74">Plugin &#39;tpope/vim-fugitive&#39;
</span><span style="color:#e6db74">&#34;</span> plugin from http://vim-scripts.org/vim/scripts.html
Plugin <span style="color:#e6db74">&#39;L9&#39;</span>
<span style="color:#e6db74">&#34; Git plugin not hosted on GitHub
</span><span style="color:#e6db74">Plugin &#39;git://git.wincent.com/command-t.git&#39;
</span><span style="color:#e6db74">&#34;</span> git repos on your local machine <span style="color:#f92672">(</span>i.e. when working on your own plugin<span style="color:#f92672">)</span>
<span style="color:#e6db74">&#34;Plugin &#39;file:///home/gmarik/path/to/plugin&#39;
</span><span style="color:#e6db74">&#34;</span> The sparkup vim script is in a subdirectory of this repo called vim.
<span style="color:#e6db74">&#34; Pass the path to set the runtimepath properly.
</span><span style="color:#e6db74">Plugin &#39;rstacruz/sparkup&#39;, {&#39;rtp&#39;: &#39;vim/&#39;}
</span><span style="color:#e6db74">&#34;</span> Avoid a name conflict with L9
<span style="color:#e6db74">&#34;Plugin &#39;user/L9&#39;, {&#39;name&#39;: &#39;newL9&#39;}
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">Plugin &#39;The-NERD-tree&#39;
</span><span style="color:#e6db74">Plugin &#39;bling/vim-airline&#39;
</span><span style="color:#e6db74">Plugin &#39;fatih/vim-go&#39;
</span><span style="color:#e6db74">Plugin &#39;nsf/gocode&#39;
</span><span style="color:#e6db74">Plugin &#39;Tagbar&#39;
</span><span style="color:#e6db74">Plugin &#39;Valloric/YouCompleteMe&#39;
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">&#34;</span> All of your Plugins must be added before the following line
call vundle#end<span style="color:#f92672">()</span> <span style="color:#e6db74">&#34; required
</span><span style="color:#e6db74">filetype plugin indent on &#34;</span> required
<span style="color:#e6db74">&#34; To ignore plugin indent changes, instead use:
</span><span style="color:#e6db74">&#34;</span>filetype plugin on
<span style="color:#e6db74">&#34;
</span><span style="color:#e6db74">&#34;</span> Brief help
<span style="color:#e6db74">&#34; :PluginList - lists configured plugins
</span><span style="color:#e6db74">&#34;</span> :PluginInstall - installs plugins; append <span style="color:#e6db74">`</span>!<span style="color:#e6db74">`</span> to update or just :PluginUpdate
<span style="color:#e6db74">&#34; :PluginSearch foo - searches for foo; append `!` to refresh local cache
</span><span style="color:#e6db74">&#34;</span> :PluginClean - confirms removal of unused plugins; append <span style="color:#e6db74">`</span>!<span style="color:#e6db74">`</span> to auto-approve removal
<span style="color:#e6db74">&#34;
</span><span style="color:#e6db74">&#34;</span> see :h vundle <span style="color:#66d9ef">for</span> more details or wiki <span style="color:#66d9ef">for</span> FAQ
<span style="color:#e6db74">&#34; Put your non-Plugin stuff after this line
</span></code></pre></div><ul>
<li>
<p>vim 실행해서 “ :PluginInstall “ 을 해서 지정된 플러그인들을 설치합니다.</p>
</li>
<li>
<p>NERDTree의 설정을 합니다.</p>
</li>
</ul>
<pre><code>$ sudo vim /etc/vim/vimrc.local
</code></pre><p>을 열어서 적당한 곳에 아래의 내용을 붙여넣습니다.</p>
<pre><code>nmap &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;
let NERDTreeWinPos=&quot;left&quot;
</code></pre><ul>
<li>Tagbar 설정<br>
위의 NERDTree 설정 부분 아래에 추가합니다.</li>
</ul>
<pre><code>nmap &lt;F3&gt; :Tagbar&lt;CR&gt;
let Tagbar=&quot;right&quot;
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
    \ }
</code></pre><p>추가) vim-go 설치가 완료되고 난 다음에,<br>
$GOPATH/bin 에 생성되어 있는, errcheck, gocode, gofmt, golint, gotags, goimports, gorename, oracle
를 /usr/local/go/bin 에 복사/붙여넣기 합니다.</p>
<p>[참고] <a href="https://gist.github.com/jaehoonn/47d81a29b620a0d64f80">https://gist.github.com/jaehoonn/47d81a29b620a0d64f80</a></p>
<ul>
<li>YouCompleteMe 설치<br>
YouCompleteMe의 설치를 완료하기 위해서 Bundle 디렉토리로 이동해서 Go언어 자동완성이 가능하도록 옵션을 지정해서 install을 합니다.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cd ~/.vim/bundle/YouCompleteMe
$ ./install.py --gocode-completer
</code></pre></div><ul>
<li>cscope를 사용하기 위한 설정<br>
[참고] <a href="https://github.com/jaehoonn/log/blob/master/cscope.md">https://github.com/jaehoonn/log/blob/master/cscope.md</a><br>
[script] <a href="https://gist.github.com/jaehoonn/bc257991fe8932944d8fa9a9556eb223">https://gist.github.com/jaehoonn/bc257991fe8932944d8fa9a9556eb223</a></li>
</ul>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="8444244371421612"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="March 6, 2015">March 6, 2015</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/go_pkg-config/" rel="bookmark">pkg-config 사용</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>Go언어를 사용하다보면 C로 만들어진 라이브러리를 사용하기 위해서 cgo가 필요할 때 가 있습니다.
라이브러리를 링크하고 하는 몇 가지 절차를 거치게 되는데, 이때 pkg-config라는걸 사용하면 편리합니다.</p>
<p>pkg-config를 사용하면 컴파일하는데 필요한 라이브러리와 헤더정보를 Go코드상에서 동일한 경로로 제공해줄 수 있게 됩니다.</p>
<p>pkg-config가 설치되어 있지 않을 경우에는 다음과 같이 설치를 해줄 수 있습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Shell" data-lang="Shell">$ sudo apt-get install pkg-config
</code></pre></div><p>이제 설치되어 있는 라이브러리 목록을 한번 보겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Shell" data-lang="Shell">$ pkg-config --list-all
</code></pre></div><p>현재 설치된 라이브러리들의 정보가 나오게 됩니다.</p>
<p>그런데 내가 원하는 라이브러리의 정보가 나타나지 않습니다.</p>
<p>라이브러리 정보의 관리는 /usr/lib/pkgconfig 경로에 있는 .pc 파일들을 통해서 됩니다.
직접 소스를 컴파일해서 사용하는 라이이브러리의 경우 /usr/local/lib/pkgconfig 에 있는 경우도 있습니다. 또는 Qt와 같은 경우에는 /home/{user}/Qt5.4.1/5.4/gcc_64/lib/pkgconfig 의 경로에 pc파일이 존재합니다.</p>
<p>이렇게 기본경로가 아닌곳에 존재하는 pc파일들을 관리하기 위해서 PKG_CONFIG_PATH라는 환경변수를 사용할 수 있습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Shell" data-lang="Shell">$ export PKG_CONFIG_PATH<span style="color:#f92672">=</span>”$PKG_CONFIG_PATH:/home/<span style="color:#f92672">{</span>user<span style="color:#f92672">}</span>/Qt5.4.1/5.4/gcc_64/lib/pkgconfig”
</code></pre></div><p>와 같이 해줍니다. 구분은 &ldquo;:&rdquo; 로 합니다.</p>
<p>[참고] <a href="http://ko.wikipedia.org/wiki/Pkg-config">http://ko.wikipedia.org/wiki/Pkg-config</a><br>
[참고] <a href="http://tjcplpllog.blogspot.kr/2014/08/pkg-config.html">http://tjcplpllog.blogspot.kr/2014/08/pkg-config.html</a><br>
[참고] <a href="http://blog.daum.net/heyjun/15705389">http://blog.daum.net/heyjun/15705389</a><br>
[참고] <a href="http://mwmw7.tistory.com/160">http://mwmw7.tistory.com/160</a><br>
[참고] <a href="http://ubuntuforums.org/showthread.php?t=751456">http://ubuntuforums.org/showthread.php?t=751456</a><br>
[참고] <a href="http://manual-archive.blogspot.kr/2011/08/pkg-config-pc-pkgconfigpath.html">http://manual-archive.blogspot.kr/2011/08/pkg-config-pc-pkgconfigpath.html</a><br>
[참고] <a href="http://ubuntuforums.org/showthread.php?t=1091717">http://ubuntuforums.org/showthread.php?t=1091717</a><br>
[참고] <a href="http://blog.naver.com/supsup5642/60161284657">http://blog.naver.com/supsup5642/60161284657</a></p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="8444244371421612"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="December 10, 2014">December 10, 2014</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/go_golang-channels-tutorial/" rel="bookmark">Golang channels tutorial</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>최근에 goroutine과 channel에 대해서 학습하다가 설명이 잘 되어 있는 글을 찾아서 번역(이라고 하기에는 뭐하고 정리?) 를 해봤습니다.
제대로 이해를 못하고 잘 못 번역을 한 부분이 있을 수 도 있으니&hellip;꼭 원본을 보길 권장합니다.</p>
<p>원본 : <a href="http://guzalexander.com/2013/12/06/golang-channels-tutorial.html">http://guzalexander.com/2013/12/06/golang-channels-tutorial.html</a></p>
<hr>
<p>Go언어는 병렬 프로그램 작성을 위해서 내장 도구를 갖고 있습니다. go를 함수 호출 앞에 놓으면 동일한 주소에 위치하는 코드를 독립적인 병렬 스레드로 실행을 시작합니다. 이런 쓰레드를 Go언어에서는 goroutine이라고 부릅니다. 여기에서 말하는 concurrently는  parallel을 의미하지는 않습니다. (역주: 그렇지만 번역은 “병렬” 이라고 칭하겠습니다.) Goroutines은 하드웨어에서 병렬(parallel) 실행이 가능할때 병렬(concurrent)아키텍처를 생성하는 것을 의미 합니다.
Concurrency is not parallelism 에 대한 토크가 있습니다.<br>
goroutine 예제를 실행해 보겠습니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#75715e">// Start a goroutine and execute println concurrently
</span><span style="color:#75715e"></span>     <span style="color:#66d9ef">go</span> println(<span style="color:#e6db74">&#34;goroutine message&#34;</span>)
     println(<span style="color:#e6db74">&#34;main function message&#34;</span>)
}
</code></pre></div><p>이 프로그램은 &ldquo;main function message” 와 아마도 &ldquo;goroutine message” 를 찍을 것입니다. 아마도 라고한건 goroutine 몇 가지 특징이 나타날 수 있기 때문입니다. 코드를 호출하는 goroutine이 시작될때, main함수는 goroutine이 끝나기를 기다리지 않고, 계속해서 실행이 됩니다. main 함수는 println을 호출하고 나서 실행을 종료합니다 그리고 Go언어에서 그건 생성된 모든 goroutine들과 전체 프로그램의 실행 중지를 말합니다. 그렇지만 그러한 일이 발생하기전에 우리의 goroutine은 “goroutine message” 문자를 인쇄하고 코드 실행을 완료 할 수 있을 겁니다.</p>
<p>알다시피 이런 상황을 피할 수 있는 어떤 방법이 있어야만 합니다. 그래서 Go언어에는 channel 이란게 있습니다.</p>
<h2 id="channels-basics">Channels basics</h2>
<p>Channel은 동시에 동작하는 함수들의 실행을 동기화하고 특정한 값을 넘겨서 그들이 대화할 수 있는 방법을 제공합니다. Channel은 몇 가지의 특징이 있습니다: channel을 통해서 보낼 수 있는 타입의 요소는, 용량(capacity:버퍼의 사이즈) 그리고 “&lt;-” 연산자로 지정된 커뮤니케이션의 방향이 있습니다. make 함수를 사용해서 channel을 할당할 수 있습니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)       <span style="color:#75715e">// by default the capacity is 0
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// non-zero capacity
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> make(<span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)          <span style="color:#75715e">// can only read from
</span><span style="color:#75715e"></span><span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> []<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">FileInfo</span>) <span style="color:#75715e">// can only write to
</span></code></pre></div><p>Channel은 first-class values(역주: first-class object의 의미로 생각했음) 이고 다른 변수들처럼 어디에서나 사용될 수 있습니다: 구조체의 요소, 함수의 인자로, 함수에서 반환되는 값으로 그리고 다른 channel을 위한 타입으로도 사용될 수 있습니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// a channel which:
</span><span style="color:#75715e">//  - you can only write to
</span><span style="color:#75715e">//  - holds another channel as its value
</span><span style="color:#75715e"></span><span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)

<span style="color:#75715e">// function accepts a channel as a parameter
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">readFromChannel</span>(<span style="color:#a6e22e">input</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>) {}

<span style="color:#75715e">// function returns a channel
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getChannel</span>() <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span> {
     <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}
</code></pre></div><p>channel을 쓰고 읽기 위해서 “&lt;-” 연산자가 있습니다. channel 변수에 대해서 상대적인 연산자의 위치에 따라서 읽기 또는 쓰기 동작이 정해집니다. 다음 예제에서 그 사용법을 보여주고 있지만, 이 코드는 나중에 설명할 몇 가지 원인 때문에 동작하지 않습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
     <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">42</span>    <span style="color:#75715e">// write to a channel
</span><span style="color:#75715e"></span>     <span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span> <span style="color:#75715e">// read from a channel
</span><span style="color:#75715e"></span>     println(<span style="color:#a6e22e">val</span>)
}
</code></pre></div><p>이제 channel이 무엇인지, 어떻게 만들고 기본 동작의 수행을 어떻게 하는지 알았으니, 첫번째 예제로 돌아가서 channel이 어떻게 도움을 주는지 알아보겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#75715e">// Create a channel to synchronize goroutines
</span><span style="color:#75715e"></span>     <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)

     <span style="color:#75715e">// Execute println in goroutine
</span><span style="color:#75715e"></span>     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
          println(<span style="color:#e6db74">&#34;goroutine message&#34;</span>)

          <span style="color:#75715e">// Tell the main function everything is done.
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// This channel is visible inside this goroutine because
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// it is executed in the same address space.
</span><span style="color:#75715e"></span>          <span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">true</span>
     }()

     println(<span style="color:#e6db74">&#34;main function message&#34;</span>)
     <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span> <span style="color:#75715e">// Wait for the goroutine to finish
</span><span style="color:#75715e"></span>}
</code></pre></div><p>이 프로그램은 두 메세지를 인쇄 할 것 입니다. 왜? “done” channel은 버퍼 없기 때문입니다. unbuffered channel에서 모든 동작은 수신자와 송신자 모두가 통신 준비가 되기 전까지 실행이 멈춰 있게 됩니다. 그게 unbuffered channel을 동기식이라고 부르는 이유입니다. “&lt;-done” 으로 읽는 작업을 하는 main 함수는 goroutine에서 channel에 data를 쓰기 전까지 동작이 블락될 것 입니다. 그래서 읽는 작업이 성공한 후에만 프로그램이 끝납니다.</p>
<p>다음의 경우 버퍼가 완전히 차있지 않으면 쓰는 동작을 할 수 있고, 버퍼가 비어 있지 않으면 블럭없이 성공적으로 모두 읽을 수 있는 버퍼를 갖고 있습니다. 이러한 channel을 비동기식이라고 부릅니다. 동기와 비동기의 차이를 보여주는 예는 다음과 같습니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#a6e22e">message</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>) <span style="color:#75715e">// no buffer
</span><span style="color:#75715e"></span>     <span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>

     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
          <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">count</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
               <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;send message&#34;</span>)
               <span style="color:#a6e22e">message</span><span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;message %d&#34;</span>, <span style="color:#a6e22e">i</span>)
          }
     }()

     <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>)

     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">count</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
          <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">message</span>)
     }
}
</code></pre></div><p>이 예에서 “message” 는 동기식 channel이고 그 결과 입니다:</p>
<pre><code>send message
// wait for 3 seconds
message 1
send message
send message
message 2
message 3
</code></pre><p>goroutine에서 channel에 첫번째 쓰는 동작을 하고 난 후에 channel에 모든 쓰기 동작은 첫번째 읽기 동작이 수행되기전 (대략 3초 후)까지 블락되었습니다.</p>
<p>이제 “message” channel에서  버퍼를 제공해보겠습니다. 즉 새로 작성한 라인은 “message := make(chan string, 2)” 처럼 보일것입니다. 이번에는 결과과 다음과 같이 보일겁니다:</p>
<pre><code>send message
send message
send message
// wait for 3 seconds
message 1
message 2
message 3
</code></pre><p>이제 3개의 message를 저장할 수 있도록 한 channel의 버퍼에서 첫 번째 읽기를 위한 대기 없이 모든 쓰기 동작을 할 수 있는 걸 볼 수 있습니다. channel의 capacity를 변경해서 시스템의 처리량을 제한하고 정보량을 제어할 수 있게 되었습니다.</p>
<h2 id="deadlock">Deadlock</h2>
<p>이제 실행할 수 없었던 읽고/쓰기 동작 예제로 돌아가 보겠습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
     <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">42</span>    <span style="color:#75715e">// write to a channel
</span><span style="color:#75715e"></span>     <span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span> <span style="color:#75715e">// read from a channel
</span><span style="color:#75715e"></span>     println(<span style="color:#a6e22e">val</span>)
}
</code></pre></div><p>실행해 보면 이런 에러들을 볼 수 있습니다.(상세한건 다를 수 있습니다.)</p>
<pre><code>fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
     /fullpathtofile/channelsio.go:5 +0x54
exit status 2
</code></pre><p>이 에러를 deadlock이라고 부릅니다. 이 상황은 두 goroutine이 서로를 기다리면서 둘 다 실행을 할 수 없는 것입니다. Go언어는 런타임에서 deadlock을 찾을 수 있기 때문에 이런 에러를 볼 수 있습니다. 커뮤니케이션 동작이 블락되었기 때문에 에러가 발생한 것입니다.</p>
<p>이 코드는 싱글쓰레드에서 한줄 씩, 차례대로 실행됩니다. 프로그램 실행이 channel에 쓰기 동작( c &lt;- 42 ) 에서 블락되어 있는건, 우리가 알고 있는 것 처럼, 동기 channel에서 쓰기 동작은 그걸 받는 쪽에서 데이터를 받을 준비가 되어야만 성공할 수 있기 때문입니다. 그래서 다음 라인에 리시버를 만들어 주기만 하면 됩니다.</p>
<p>이 코드를 동작하게 하기 위해 다음과 같이 작성하면 됩니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
     
     <span style="color:#75715e">// Make the writing operation be performed in
</span><span style="color:#75715e"></span>     <span style="color:#75715e">// another goroutine.
</span><span style="color:#75715e"></span>     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { 
        <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">42</span> 
     }()
     <span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>
     println(<span style="color:#a6e22e">val</span>)
}
</code></pre></div><h2 id="range-channels-and-closing">Range channels and closing</h2>
<p>앞의 예제들중에 하나에서 channel에 여러 메세지를 보내고 그걸 읽었다. 받는 부분의 코드이다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">count</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">message</span>)
}
</code></pre></div><p>읽는 동작에서 deadlock이 없게 하기 위해서, 보낸 메세지의 수를 정확하게 알고 있어야 한다. 더 많이 보내게 되면 읽을 수가 없다.이건 아주 불편하다. 이걸 좀 더 일반적인 코드로 작성하면 좋을것 같다.</p>
<p>Go언어에는 array, string, slice, map 그리고 channel의 반복자를 사용할 수 있는 range expression 이 있다. channel을 close 하기전까지 반복처리를 한다. 다음 예제를 보자(지금 동작하지 않는다.):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#a6e22e">message</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)
     <span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>

     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
          <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">count</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
               <span style="color:#a6e22e">message</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;message %d&#34;</span>, <span style="color:#a6e22e">i</span>)
          }
     }()

     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">message</span> {
          <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">msg</span>)
     }
}
</code></pre></div><p>이 코드는 동작하지 않습니다. 위에서 말한대로 range는 channel이 close되기 전까지 작업을 계속하게 됩니다. close 함수로 channel을 닫아줘야만 합니다. goroutine 부분은 이처럼 보여질겁니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">count</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
          <span style="color:#a6e22e">message</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;message %d&#34;</span>, <span style="color:#a6e22e">i</span>)
     }
     close(<span style="color:#a6e22e">message</span>)
}()
</code></pre></div><p>channel을 close 하게 되면 한가지 더 유용한 기능이 있습니다. - 닫힌 channel 에 읽기 동작을 하면 블락이 되지 않고 channel 타입의 기본값을 반환합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
close(<span style="color:#a6e22e">done</span>)

<span style="color:#75715e">// Will not block and will print false twice 
</span><span style="color:#75715e">// because it’s the default value for bool type
</span><span style="color:#75715e"></span>println(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>)
println(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>)
</code></pre></div><p>이 방법은 goroutine의 동기화에 사용할 수도 있습니다. 예제중에 하나를 동기화 해보겠습니다 :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)

     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
          println(<span style="color:#e6db74">&#34;goroutine message&#34;</span>)

          <span style="color:#75715e">// We are only interested in the fact of sending itself, 
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// but not in data being sent.
</span><span style="color:#75715e"></span>          <span style="color:#a6e22e">done</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">true</span>
     }()

     println(<span style="color:#e6db74">&#34;main function message&#34;</span>)
     <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span> 
}
</code></pre></div><p>여기에서 “done” channel은 오직 실행을 동기화 하는데만 쓰이고 데이터를 전송하지는 못 합니다. 이럴때 사용하는 패턴이 있습니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#75715e">// Data is irrelevant
</span><span style="color:#75715e"></span>     <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})

     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
          println(<span style="color:#e6db74">&#34;goroutine message&#34;</span>)

          <span style="color:#75715e">// Just send a signal &#34;I&#39;m done&#34;
</span><span style="color:#75715e"></span>          close(<span style="color:#a6e22e">done</span>)
     }()

     println(<span style="color:#e6db74">&#34;main function message&#34;</span>)
     <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>
}
</code></pre></div><p>goroutine에서 close한 channel에 읽기 동작을 하면 블럭되지도 않고 main 함수도 계속 실행이 된다.</p>
<h2 id="multiple-channels-and-select">Multiple channels and select</h2>
<p>실제 프로그램에서는 더 많은 goroutine과 channel이 필요할것입니다. 독립적인 부분이 많아지면 더 효과적인 동기화가 필요할겁니다. 복잡한 예제를 보겠습니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getMessagesChannel</span>(<span style="color:#a6e22e">msg</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">delay</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>) <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span> {
     <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)
     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
          <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
               <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%s %d&#34;</span>, <span style="color:#a6e22e">msg</span>, <span style="color:#a6e22e">i</span>)
               <span style="color:#75715e">// Wait before sending next message
</span><span style="color:#75715e"></span>               <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">delay</span>)
          }
     }()
     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
     <span style="color:#a6e22e">c1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getMessagesChannel</span>(<span style="color:#e6db74">&#34;first&#34;</span>, <span style="color:#ae81ff">300</span>)
     <span style="color:#a6e22e">c2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getMessagesChannel</span>(<span style="color:#e6db74">&#34;second&#34;</span>, <span style="color:#ae81ff">150</span>)
     <span style="color:#a6e22e">c3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getMessagesChannel</span>(<span style="color:#e6db74">&#34;third&#34;</span>, <span style="color:#ae81ff">10</span>)

     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
          println(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c1</span>)
          println(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c2</span>)
          println(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c3</span>)
     }
}
</code></pre></div><p>우리는 channel을 만들고 일정한 간격으로 3개의 메세지로 channel을 채우는 goroutine을 생성하는 함수를 갖고 있습니다. 3번째 channel c3는 제일 짧은 간격이라서 다른것들보다 먼저 메세지가 보여지게 될 것 같습니다. (역주: except 가 아니라 expect 인것 같습니다.) 그렇지만 결과는 다음과 같습니다:</p>
<pre><code>first 1
second 1
third 1
first 2
second 2
third 2
first 3
second 3
third 3
</code></pre><p>분명히 연속해서 출력되었습니다. 300밀리초단위로 루프 반복과 다른 작업을  하는 첫번쨰 channel에 대한 읽기 동작은 기다려야하기 때문입니다. 우리는 실제로 모든 channel에서 어떤것이든 바로 메세지를 읽기를 원합니다.</p>
<p>여러 channel에서 커뮤니케이션 작업을 위해서 Go언어에는 “select” 가 있습니다. “switch”와 비슷하지만, 모든 case에는 커뮤니케이션 동작(read, write)만 있습니다. “case”의 동작이 수행되면 그에 맞는 코드 블록이 실행됩니다. 그래서 우리가 원하는걸 하도록 작성하면됩니다:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">9</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
     <span style="color:#66d9ef">select</span> {
     <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c1</span>:
          println(<span style="color:#a6e22e">msg</span>)
     <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c2</span>:
          println(<span style="color:#a6e22e">msg</span>)
     <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c3</span>:
          println(<span style="color:#a6e22e">msg</span>)
     }
}
</code></pre></div><p>숫자 9는 channel에서 3번 쓰는 동작을 합니다. 그래서 9번 루프를 돌면서 select를 했습니다. 프로그램에서 무한 루프로 “select”를 실행하는건 보통 데몬으로서 실행되는걸 의미합니다. 그렇지만 여기에서는 한번 실행이 되고나면 deadlock에 걸리게 될 것입니다.</p>
<p>이제 예상한 결과를 얻었습니다. 그리고 읽기 작업중에 다른 작업을 차단하지 않습니다. 결과입니다:</p>
<pre><code>first 1
second 1
third 1 // this channel does not wait for others
third 2
third 3
second 2
first 2
second 3
first 3
</code></pre><h2 id="conclusion">Conclusion</h2>
<p>Channel은 Go언어에서 아주 강력하고 흥미로운 구조입니다. 그렇지만 그걸 효과적으로 사용하기 위해서는 어떻게 동작하는지 꼭 이해를 해야합니다. 여기에서는 꼭 필요한 기본들에 대해서만 설명을 했습니다. 더 학습하기 위해서 다음들을 보면 좋을 것 같습니다.</p>
<ul>
<li><a href="https://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a> - early mentioned talk from Rob Pike</li>
<li><a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a></li>
<li><a href="https://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a></li>
</ul>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="8444244371421612"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="October 8, 2013">October 8, 2013</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/go_md5/" rel="bookmark">md5 패키지 사용예</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>Qt로 만드는 클라이언트에서 이미지 파일에 대해서 만들어진 md5 hash를 검증 해보기 위해서, 같은 이미지 파일에 대해서 Go언어로 md5 hash를 만들었을때 동일한 값이 생성되면 제대로 만들어진거 아닐까 해서, 만들어 봤습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
  <span style="color:#e6db74">&#34;io/ioutil&#34;</span>
  <span style="color:#e6db74">&#34;crypto/md5&#34;</span>
  <span style="color:#e6db74">&#34;fmt&#34;</span>
)
 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadFile</span>(<span style="color:#e6db74">&#34;1.jpg&#34;</span>)
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#66d9ef">return</span>;
  }
 
  <span style="color:#a6e22e">hash</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">md5</span>.<span style="color:#a6e22e">New</span>() 
  <span style="color:#a6e22e">hash</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">data</span>)
  <span style="color:#a6e22e">hashData</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">hash</span>.<span style="color:#a6e22e">Sum</span>(<span style="color:#66d9ef">nil</span>)
 
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%x&#34;</span>, <span style="color:#a6e22e">hashData</span>)
}
</code></pre></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="8444244371421612"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="September 17, 2013">September 17, 2013</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/go_go-slice-from-c-array/" rel="bookmark">C언어의 배열을 Go언어의 slices로 변환</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>cgo를 이용하다보면, C언어로 작성된 라이브러리의 리턴값으로 포인터에 구조체가 할당되어서 넘어올때가 있습니다.<br>
C언어에서 넘어오는 구조체 배열이 포인터 형태로 넘어오니, Go의 포인터에 할당을 해서 사용 해봤습니다.<br>
당연히 제대로 동작하지 않습니다. C언어로 작성된 라이브러리에서 넘어오는 값은 배열이니, Go언어에서는 slices에 할당을 하는게 맞는것 같습니다.</p>
<p>다음의 내용을 보면, array를 어떻게 slices에 할당을 해야 할지에 대해서 잘 설명이 되어 있습니다.<br>
&ldquo;Turning C arrays into Go slcies&rdquo; ( <a href="https://code.google.com/p/go-wiki/wiki/cgo">https://code.google.com/p/go-wiki/wiki/cgo</a> )</p>
<p>아래는 cubrid driver를 만들면서 사용한 코드입니다.</p>
<pre><code>slcieHeader := (*reflect.SliceHeader)(unsafe.Pointer(&amp;go_col_info)))
sliceHeader.Cap = int(col_count)
sliceHeader.Len = int(col_count)
sliceHeader.Data = uintptr(unsafe.Pointer(c_col_info))
</code></pre><ul>
<li>예제<br>
<a href="https://github.com/jaehoonn/cubrid/blob/master/cas_gci.go">https://github.com/jaehoonn/cubrid/blob/master/cas_gci.go</a></li>
</ul>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="8444244371421612"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="September 3, 2013">September 3, 2013</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/go_cgo-type/" rel="bookmark">type으로 이름 붙여진 구조체의 필드를 사용하기위한 방법</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>c로 만들어져 있던 라이브러리를 cgo를 이용해서 포팅(?)을 하는 작업을 하다보면 난감한 부분들이 종종 나타납니다.</p>
<p>그중에 한가지가 c에서 사용하던 구조체의 파라미터명이 go 에서 미리정의된 명칭일 경우가 있습니다.<br>
대표적인 예로 &ldquo;type&quot;이라는 파라미터명 입니다.<br>
c에서는 T_CCI_COL_INFO(cubrid의 cci에서 사용되는 구조체중에 하나) 의 필드중에 하나가 type이라는 필드가 하나 있습니다.<br>
이걸 go에서 사용을 하려고 하니,,,<br>
&ldquo;&hellip;expected selector or type assertion, found &lsquo;type&rsquo; &quot;  이라는 결과를 만나게 됩니다.</p>
<p>이걸 도대체 어떻게 사용해야 하나 고민을 하던중, golang.org 에 있는 문서 <a href="http://golang.org/cmd/cgo/">http://golang.org/cmd/cgo/</a> 에서 해결을 할 수 있었습니다.</p>
<blockquote>
<p>Within the Go file, C identifiers or field names that are keywords in Go can be accessed by prefixing them with an underscore: if x points at a C struct with a field named &ldquo;type&rdquo;, x._type accesses the field.</p>
</blockquote>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="8444244371421612"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="August 23, 2013">August 23, 2013</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/go_testing/" rel="bookmark">패키지 만들때 testing 패키지 사용하기</a>
						</h1>
					</header>
					<div class="entry-content">
						<h2 id="개요">개요</h2>
<p>Go 언어용 패키지를 만들려면, 테스트코드를 작성해야 진행이 좀 더 원활하게 되는것 같습니다.<br>
그래서 간단하게 테스트 코드 작성하는 방법을 정리해봤습니다.</p>
<h2 id="abc-패키지를-만들어서-테스트하기">abc 패키지를 만들어서 테스트하기</h2>
<p>src\abc\abc.go<br>
src\abc\abc_test.go
와 같이 파일을 만들어 놓습니다.</p>
<p>abc.go를 다음과 같이 작성합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// abc.go
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">abc</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">A_Method</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;test A Method&#34;</span>)
}
</code></pre></div><p>그리고 abc_test.go를 다음과 같이 작성합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// abc_test.go
</span><span style="color:#75715e"></span>
<span style="color:#f92672">package</span> <span style="color:#a6e22e">abc</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;testing&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestA_Method</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
    <span style="color:#a6e22e">A_Method</span>()
}
</code></pre></div><p>그리고 $GOPATH/src/abc/ 에서</p>
<pre><code>$ go test
</code></pre><p>를 하면 테스트가 진행됩니다.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="8444244371421612"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
			</div>
		</div>

		<center class="">
			<ul class="pagination">
        
<ul class="pagination">
  <li class="page-item">
    <a href="/post/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/post/page/5/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/2/">2</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/3/">3</a>
  </li>
  <li class="page-item disabled">
    <span aria-hidden="true">&nbsp;&hellip;&nbsp;</span>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/5/">5</a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/post/page/6/">6</a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/post/page/6/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


			</ul>
		</center>
	</div>	

</main>

    
    
      <footer id="footer">
	<div class="container">
		<div class="row">
			

			
			<div class="col-md-3 widget">
				<h3 class="widget-title">Follow me</h3>
				<div class="widget-body">
					<p class="follow-me-icons">
            
							
								<a href="https://www.facebook.com/jaehoon" target="_blank"><i class="fab fa-facebook-square fa-1x"></i></a>
							
            
							
								<a href="https://twitter.com/jaehoonn_" target="_blank"><i class="fab fa-twitter-square fa-1x"></i></a>
							
            
							
								<a href="https://github.com/jaehoonn" target="_blank"><i class="fab fa-github fa-1x"></i></a>
							
            
							
								<a href="mailto:jaehoon@shrinklabs.com" target="_blank"><i class="fas fa-envelope-square fa-1x"></i></a>
							
            
					</p>
				</div>
			</div>
			

			

			

		</div> 
	</div>
</footer>

<footer id="underfooter">
	<div class="container">
		<div class="row">

			<div class="col-md-6 widget">
				<div class="widget-body">
					<p></p>
				</div>
			</div>

			<div class="col-md-6 widget">
				<div class="widget-body">
					<p class="text-right">
						Copyright &copy; 2021, <br>
						Design: <a href="http://www.gettemplate.com" rel="designer">Initio by GetTemplate</a> - 
						Powered by: <a href="https://gohugo.io/" rel="poweredby">Hugo</a>
					</p>
				</div>
			</div>

		</div> 
	</div>
</footer>




<script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>




<script src="https://shrinklabs.com/js/bundle.min.b4d4f6818b4e26d94fb4399ccecba55248c6c39b666a474da4289f5f9dd5de310f550d6db5ab597255174ef0acf2fd488c3e5d92f0cabc10600c94b70c601f28.js" integrity="sha512-tNT2gYtOJtlPtDmczsulUkjGw5tmakdNpCifX53V3jEPVQ1ttatZclUXTvCs8v1IjD5dkvDKvBBgDJS3DGAfKA=="></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-4LRCTZDF74', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>

    
  </body>
  
</html>