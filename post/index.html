<!DOCTYPE html>
<html lang="en">
  <head>
  	<meta charset="utf-8">
  	<meta name="viewport"    content="width=device-width, initial-scale=1.0">
  	<meta name="description" content="">
  	<meta name="author"      content="map[]">
    
    	<title>Posts</title>
    
    <script data-ad-client="ca-pub-8444244371421612" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


	<link rel="shortcut icon" href="https://shrinklabs.com/images/favicon.ico">

	
	<link href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css" rel="stylesheet">
	
	
	<script defer src="https://use.fontawesome.com/releases/v5.0.11/js/all.js" integrity="sha384-ImVoB8Er8knetgQakxuBS4G3RSkyD8IZVVQCAnmRJrDwqJFYUE4YOv+DbIofcO9C" crossorigin="anonymous"></script>
	
	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Alice|Open+Sans:400,300,700">
	
	
  
  <link rel="stylesheet" href="https://shrinklabs.com/css/styles.min.64a6643395c6bf1ec6fff31d6429046b3ad467e58a279ff252dc019edd80a87051cf90b7fe2d589277def72d84602dcbc7115e2e17a94db3a8838336986a0ae3.css" integrity="sha512-ZKZkM5XGvx7G//MdZCkEazrUZ&#43;WKJ5/yUtwBnt2AqHBRz5C3/i1Yknfe9y2EYC3LxxFeLhepTbOog4M2mGoK4w==">

   
  

  </head>
  
  <body class="home">

    
      <header id="header">
  <div id="head" class="parallax" data-parallax-speed="2" style="background-image:url('https://shrinklabs.com/images/bg_head.jpg');">
    <h1 id="logo" class="text-center">
      <img class='img-circle' src="https://shrinklabs.com/images/logo.png" alt="">
      <span class="title"></span>
      <span class="tagline"><br>
        <a href="mailto:"></a>
      </span>
   </h1>
</div>

<nav class="navbar navbar-default navbar-sticky">
    <div class="container-fluid">

        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="true">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>

        <div class="navbar-collapse collapse" id="bs-example-navbar-collapse-1">

            <ul class="nav navbar-nav">
            
                
                <li>
                    <a href="/">home</a>
                </li>
                
            
                
                <li>
                    <a href="/post/">blog</a>
                </li>
                
            
            </ul>

        </div> 
        
    </div>
</nav>

</header>
    
 
    
<main id="main">

	<div class="container">
		<div class="row topspace">
			<div class="col-sm-8 col-sm-offset-2">

        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="June 16, 2021">June 16, 2021</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/scheduler_an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler/" rel="bookmark">내결함성 수평 확장성이 있는 분산형 이벤트 스케줄러 설계 방법</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>이 글은 원글(<a href="https://medium.com/walmartglobaltech/an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler-278c9c380637">An Approach to Designing a Distributed, Fault-Tolerant, Horizontally Scalable Event Scheduler</a>)의 저작자 Sandeep Malik씨의 허락을 받고 번역한 글 입니다.</p>
<hr>
<h1 id="소개">소개</h1>
<p>시간 기반 이벤트 스케줄러를 설계하는 것은 항상 흥미로운 문제입니다. 규모에 맞게 작업을 수행하는 것은 훨씬 더 어려운 일입니다. 먼저 시간 기반 이벤트 스케줄러가 무엇을 의미하는지 정의해 보겠습니다.</p>
<p>시간 기반 이벤트 스케줄러는 서비스가 나중에 (<em>future</em>) 처리해야 하는 요청을 예약하는 데 사용할 수 있는 시스템입니다. 서비스는 스케줄러에 이벤트(<em>event</em>)를 등록하고 현재 요청의 처리를 일시 중단합니다.</p>
<p>정해진 시간이되면 스케줄러에 의해 요청 서비스가 통보되며, 바로 전에 중단되었던 요청의 처리를 재개할 수 있습니다. 이러한 시스템이 유용할 수 있는 많은 시나리오가 있습니다. 일부 사용 사례(전반적인 것은 아님)는 아래에 나열되어 있습니다.</p>
<h1 id="비동기-요청-시간-초과">비동기 요청 시간 초과</h1>
<p>점점 더 많은 시스템이 카프카(<a href="https://medium.com/walmartlabs/tech-transformation-real-time-messaging-at-walmart-8787f5ab19e8#.wx4sbxuse">Kafka</a>), JMS 등과 같은 메시징 기반 아키텍처로 이동함에 따라, 가장 일반적인 시나리오 중 하나는 메시징 계층을 비동기식 요청/응답 버스(bus)로 사용하는 것입니다. 한 시스템은 다른 시스템에 &ldquo;메시지 요청(<em>message request</em>)&ldquo;을 생성하고 나중에 응답을 반환하면 나머지 처리 작업을 진행합니다. 경우에 따라서는 &lsquo;최종 응답(<strong>eventual response</strong>)&lsquo;을 하는 것이 중요합니다. 다른 시스템이 지연되거나 중단되었거나 단순히 응답을 반환하지 못할 수 있습니다. 상태 비저장 마이크로 서비스 패러다임이 있는 분산 환경에서는 이러한 손실된 요청을 추적하기가 어렵습니다. 한 가지 해결책은 요청의 규정된 SLA에 따라 트리거될 수 있는 &lsquo;시간 초과(time-out)&rsquo; 이벤트를 예약하는 것일 수 있습니다.</p>
<p>이벤트가 트리거되면 요청의 현재 상태를 확인하고 응답이 없는 경우 요청을 시간 초과로 표시할 수 있습니다.</p>
<h1 id="시스템-재시도">시스템 재시도</h1>
<p>HTTP와 같은 동기식 채널을 통해 상호 작용하는 시스템의 경우에도 서버가 다운되어 요청을 처리할 수 없습니다. 클라이언트는 재시도를 선택할 수 있지만 재시도 간격이 매우 짧으면 순 긍정 효과가 나타나지 않습니다. 예를 들어, 시스템 전체에 걸쳐 운영 중단 상태가 몇 초 이상 지속될 수 있습니다. 이 경우 요청 데이터를 메모리에 저장하지 않는 지수 형태로 재시도를 더 오래 수행하는 것이 바람직할 수 있습니다.</p>
<p>이러한 경우 재시도용 페이로드를 이벤트 스케줄러로 보낼 수 있으며 클라이언트의 재시도 정책에 따라 나중에 다시 시도할 수 있습니다.</p>
<h1 id="조정-작업">조정 작업</h1>
<p>때때로 배치에 기반한 분산 시스템에서는 데이터 스트림이 여러 클러스터에 의해 마이크로 배치로 분할되고 처리됩니다. 실패의 경우, 일관성 있는 응답이 초기 배치에 대해 클라이언트에게 반환될 수 있도록 응답을 조정하는 것이 바람직할 수 있습니다.</p>
<p>이 경우 배치 처리 시작 시 조정 이벤트를 예약하여 배치 처리 또는 처리 시간 SLA 종료 시 데이터를 조정할 수 있습니다.</p>
<h1 id="가격-관련-트리거">가격 관련 트리거</h1>
<p>이커머스(eCommerce) 환경에서는 일반적으로 제품을 적절한 가격 가치로 유지하기 위해 가격을 변경합니다. 이러한 가격 변동을 촉발하는 것은 엄청난 수작업이 될 수 있고 오류가 발생하기 쉬우며, 원하는 시간에 정확하게 이루어지지 않을 수도 있습니다. 예를 들어, 블랙 프라이데이와 같은 휴가 피크 시간 동안 가격 변동이 약간 지연되더라도 연간 매출에 영향을 미칠 수 있습니다.</p>
<p>이 경우 가격 변경은 &lsquo;프로모션&rsquo;으로 미리 설정될 수 있으며, 이는 이벤트 스케줄러에 의해 필요한 시간에 트리거되어 수동 가격 동기화 작업을 절약할 수 있습니다.</p>
<p>위에서 언급한 모든 이슈들은 어느 순간인가 월마트(<a href="https://www.walmart.com/">Wallmart</a>)가 직면했고 우리는 중단된 요청을 추적할 수 있는 시스템에 투자해야 합니다는 것이 분명해졌습니다. 월마트가 운영하는 규모가 크기 때문에 스케줄러는 내결함성(fault tolerant)이 있어야 하고 수평적으로 확장 가능해야 했습니다.</p>
<h1 id="기존-옵션">기존 옵션</h1>
<p>우리는 Quartz와 같은 기존의 다양한 오픈 소스 솔루션을 찾기 시작했습니다. Quartz는 풍부한 기능을 갖춘 시간 기반 스케줄링에 대한 검증된 솔루션이지만, 우리의 문제점은 약간 달랐습니다.</p>
<ul>
<li>많은 애플리케이션이 카산드라(<a href="https://www.youtube.com/watch?v=KMHua4LUvQ0">Cassandra</a>)를 노에스큐엘(NoSql) 데이터 저장소로 사용하고 있습니다. 시간이 흐르면서 우리는 카산드라와 그것의 뉘앙스에 대해 상당한 전문지식을 키워왔습니다. Quartz에는 카산드라를 위한 JobStore가 없는 것 같습니다(또는 적어도 우리는 JobStore를 찾지 못했습니다).</li>
<li>우리는 이벤트에 대해 조정 가능한 일관성을 갖기를 원했습니다. 시스템 재시도 등과 같은 일부 이벤트의 경우, 한 노드(LOCAL_ONE)에 기록하는 것이 괜찮지만, 승격 트리거와 같은 다른 이벤트의 경우 이벤트가 손실되지 않도록 EACH_QUORUM을 사용해야 했습니다.</li>
<li>클러스터를 확장하는게 더 어려웠습니다. 우리는 시간당 수백만 개의 이벤트로 확장해야 했습니다.</li>
</ul>
<p>우리는 또한 Quartz의 해즐캐스트(Hazelcast) 기반 JobStore 구현에 대해서도 조사했지만, 장기간에 걸친 가비지 수집 주기는 실화를 초래하여 메모리 데이터의 위험이있었습니다.</p>
<h1 id="bigben-소개">BigBen 소개</h1>
<p>우리는 BigBen이라고 불리는 우리만의 솔루션을 구현하기 시작했습니다. 매우 유명한 <a href="https://en.wikipedia.org/wiki/Big_Ben">런던 시계탑</a>에서 영감을 받았습니다. BigBen은 다음과 같은 기능을 제공합니다.</p>
<ul>
<li>마스터 슬레이브 설계, 마스터가 클러스터 전체에 부하를 분산하기 위한 최상의 전략을 결정할 수 있습니다.</li>
<li>주어진 마스터가 작동 중단될 경우 거의 즉각적으로 다른 마스터를 선택할 수 있도록 내결함성(fault tolerant)이 매우 높은 설계입니다.</li>
<li>카산드라(Cassandra)의 팻 파티션(fat partitions) 측면에서 핫 포켓(hot pockets)이 없도록 데이터베이스의 이벤트 데이터를 균등하게 파티셔닝합니다.</li>
<li>모든 노드가 거의 동일한 로드를 공유하도록 클러스터에서 이벤트를 균일하게 실행합니다.</li>
<li>트리거되지 않았거나 실행되지 않은 이벤트(mis-fires)를 추적할 수 있도록 체크포인트를 유지합니다.</li>
<li>이벤트의 기본 채널로 HTTP 및 카프카(Kafka)를 통합합니다.</li>
<li>멀티 테넌시(Multi-tenancy)입니다. 각 이벤트는 하나의 테넌트에 속하며, 각 테넌트는 이벤트를 저장(일관성 보장-consistency guarantees) 및/또는 처리하는 방법에 대한 정책을 정의할 수 있습니다.</li>
</ul>
<h1 id="설계-및-아키텍처">설계 및 아키텍처</h1>
<p>BigBen은 &lsquo;마이크로 배칭(micro-batching)&rsquo; 아키텍처를 기반으로 합니다. 이벤트는 창에서 함께 버킷화되고 이러한 버킷은 데이터베이스에 파티션으로 저장됩니다.</p>
<p>클러스터가 시작되면 마스터가 선택되며, 마스터는 정의된 세분화에서 버킷 검색을 시작합니다. 지원되는 최소 단위는 1분이며, 이는 마스터가 매 분마다 이벤트를 검색합니다.</p>
<h1 id="이벤트-수집">이벤트 수집</h1>
<p>매 분마다 얼마나 많은 이벤트가 예약될지는 알 수 없으므로 버킷 너비를 기준으로 데이터를 분할하면(이 경우 1분) 데이터베이스에 불균일한 로드가 발생할 수 있습니다. 따라서 이벤트가 샤드화(sharded)되어 1개의 샤드(shard)에 1000개(구성 가능한 값) 이벤트만 저장됩니다.</p>
<p>예를 들어, 오전 10시에 2030개의 이벤트가 접수되었다고 가정하면, 그 이벤트는 3조각으로 나누어집니다. 샤드(Shard) 1에는 1000개의 이벤트가 포함되고, 샤드(shard) 2에는 1000개의 이벤트가 추가되며, 샤드(shard) 3에는 30개의 이벤트가 포함됩니다. 이러한 방식으로 시스템은 샤드(shard)당 1000개 이상의 이벤트가 발생하지 않음을 보장합니다.</p>
<p>지정된 이벤트가 할당될 샤드(shard)를 확인하려면 해당 버킷(bucket)의 실행 총 이벤트 수에 따라 다릅니다. 그런 다음 아래 공식을 사용하여 해당 이벤트에 대한 샤드 인덱스(shard index)를 계산하는 것이 매우 간단합니다.</p>
<blockquote>
<p><em>shard_index = (total_events / shard_size)</em></p>
</blockquote>
<p>예를 들어, 2030 이벤트 이후에 다음 이벤트가 접수될 때, 그것은 다음 이벤트로 갈 것입니다.</p>
<blockquote>
<p><em>2030/1000 = 2nd index (or 3rd shard)</em></p>
</blockquote>
<p>빠른 검색을 위해서는 버킷(bucket)당 실행 중인 총 이벤트 수를 유지해야 합니다. BigBen은 내장된 해즐캐스트(Hazelcast) 그리드를 사용하여 이러한 카운트를 분산 맵에서 유지할 수 있지만 원자 카운트를 지원하는 멤캐쉬(memcache), 카우치베이스(Couchbase) 등과 같은 다른 솔루션도 사용할 수 있습니다. 맵 데이터는 몇 초마다 카산드라(Cassandra)와 동기화됩니다.</p>
<p>아래 다이어그램(diagram)은 이벤트(event) 수신 흐름을 캡처합니다. HTTP 또는 카프카(Kafka)를 통해 이벤트(event)를 수신할 수 있습니다. 잘못된 이벤트(event)는 거부되고 즉시 반환됩니다(빨간 점선으로 표시됨). 다른 경우에는 해당하는 버킷(bucket)이 계산됩니다(이벤트(event)가 오전 10:21:55로 예약되어 있고, 버킷(bucket)이 오전 10:21:00로 예약되어 있음). 카운트(count)가 증가되고 샤드 인덱스(shard index)가 계산됩니다. 그러면 이벤트(event)가 버킷(bucket)과 샤드 인덱스(shard index)의 조합인 해당 파티션(partition)에 저장됩니다(예: 10:21:00/1).</p>
<p><img src="/image/an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler/1_LmYyR8GT9TjPmrRorOBzLg.png" alt="Fig 1 — Event Receive Flow"></p>
<h1 id="이벤트-처리">이벤트 처리</h1>
<p>처리 부분의 경우 클러스터 구성원 중에서 마스터가 선택됩니다. 주키퍼(Zookeeper)는 리더(leader)/마스터(master) 선택에 사용할 수 있지만, BigBen은 이미 해즐캐스트(Hazelcast)를 사용하고 있으므로 분산 잠금 기능을 사용하여 *클러스터 싱글턴(Cluster Singleton)*을 구현했습니다. 그런 다음 마스터는 다음 버킷을 예약하고 이벤트 수를 읽습니다. 이벤트 수와 샤드(shard) 크기를 알면 총 샤드(shard) 수를 쉽게 계산할 수 있습니다. 그런 다음 마스터(master)는 쌍(bucket, shard_index)을 생성하고 이를 클러스터 멤버(cluster member) 간에 <strong>균등</strong>하게 나눕니다. 분할이 동일하지 않은 경우 마스터(master)는 자신에게 최소 로드를 적용하려고 합니다. 예를 들어 오전 10시 21분 버킷(bucket), 이벤트(events) 6000개, 노드 클러스터(node cluster) 4개의 경우 다음과 같이 나뉩니다.</p>
<blockquote>
<p><em>distribution =&gt; (bucket, array of shard indexes, node IP) =&gt; (10:21, [1,5], node1), (10:21, [2,6], node2), (10:21, [3], node3), (10:21, [4], node4)</em></p>
</blockquote>
<p>마스터(master)는 또한 이전 버킷(bucket)이 실패했는지 확인하고 해당 버킷(bucket)도 예약합니다. 버킷(bucket)이 완료되면 버킷(bucket)이 처리된 것으로 표시되고 체크포인트(checkpoint)에서 상태가 업데이트됩니다. 아래 다이어그램(diagram)은 처리 단계를 나타냅니다(<em>스케줄 스캐너-schedule scanner가 마스터-master임</em>).</p>
<p><img src="/image/an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler/1_euaHLOnw6G96SigfXxWhtA.png" alt="Fig 2 — Event Processing Flow"></p>
<p>처리 워크플로우(workflow)의 다양한 구성요소는 다음과 같습니다.</p>
<ul>
<li>Bucket Manager: 로드된 버킷(bucket)의 스냅샷(snapshots)을 메모리(memory)에 유지합니다.</li>
<li>Bucket Loader: 이전 버킷(bucket)을 속도 제한/스로틀(throttled) 방식으로 메모리(memory)에 로드합니다.</li>
<li>Checkpoint Helper: 몇 초마다 체크포인트(checkpoint)를 동기화합니다.</li>
<li>Status Syncer: 버킷(bucket)의 상태를 동기화합니다.</li>
</ul>
<h1 id="내결함성fault-tolerance-설계">내결함성(Fault Tolerance) 설계</h1>
<p>다른 분산 시스템(distributed system)과 마찬가지로 여러 개의 고장 지점(failure points)이 있을 수 있습니다. 그 중 일부는 다음과 같습니다.</p>
<ul>
<li>마스터(Master)를 사용할 수 없게 됩니다.</li>
<li>이벤트(Events) 처리가 실패합니다.</li>
<li>데이터베이스(Data base)가 종료되었습니다.</li>
</ul>
<p>BigBen은 실패를 처리하기 위해 다른 기술을 사용합니다. 마스터의 내결함성(fault tolerance)을 위해 해즐캐스트(Hazelcast)에서 분산 잠금(distributed lock)을 사용합니다. 이 잠금은 노드(node)의 수명 동안 해제되지 않습니다. 노드(node)가 작동 중단된 경우에만 다른 구성원이 잠금을 획득하려고 시도합니다. 이는 매우 강력한 내결함성(fault tolerance)을 제공하며, 카오스 몽키(Chaos Monkey) 테스트 중에 이를 검증했습니다. 아래 다이어그램(diagram)은 마스터(master) 장애 조치 시나리오를 보여줍니다.</p>
<p><img src="/image/an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler/1_KRjTGz1jrWpYl2tYznV8jg.png" alt="Fig 3 — Master (Cluster Singleton) distributing tasks among slaves"></p>
<p><img src="/image/an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler/1_SHiYcpNCJcRsaAbFpXb3rw.png" alt="Fig 4 — Master down, new slave promoted to master, and starts distributing tasks"></p>
<p>이벤트(event) 처리에 실패했거나 데이터베이스가 종료된 경우 체크포인트(checkpoint)는 실패한 버킷(bucket)으로 표시됩니다. 매 새 버킷(bucket) 검색 시 마스터(master)는 체크포인트(checkpoint)도 검색하여 이전 버킷(bucket)이 실패한 상태인지 확인합니다. 발견되면 해당 버킷(bucket)도 예약됩니다.</p>
<p>BigBen은 실패한 버킷(bucket)/이벤트(events)에 대해 계속 시도하기 위해 과거까지의 범위에 대해 구성 가능한 &lsquo;look back&rsquo; 매개 변수를 사용합니다. 기본적으로 이 값은 1일입니다.</p>
<h1 id="성능-벤치마킹">성능 벤치마킹</h1>
<p>클러스터 성능(cluster’s performance)을 다음과 같은 매개 변수로 벤치마킹(bench marked)했습니다.</p>
<ul>
<li>4 대의 머신, Cent OS 6+, 8 코어, 16GB RAM, 최소 힙 2GB, 최대 힙 8GB</li>
<li>이벤트 페이로드 크기 : 500 바이트</li>
<li>카산드라(Cassandra) 6 + 6 베어 메탈 클러스터</li>
<li>쓰기 일관성 : LOCAL QUORUM</li>
<li>일관성 읽기 : LOCAL QUORUM</li>
<li>수집 속도 : 52 초 내에 수집 된 100 만 개의 이벤트. =&gt; 시간당 7 천만 이벤트</li>
<li>처리 속도 : 60 초에 100 만 이벤트 =&gt; 시간당 6 천만 이벤트</li>
</ul>
<h1 id="다음-단계">다음 단계</h1>
<p>나는 당신이 이 게시물이 유익하다고 생각하셨기를 바랍니다. <del>우리는 곧 BigBen을 오픈소스화 할 것 이므로 지켜봐 주세요.</del> 우리는 <a href="https://github.com/walmartlabs/bigben">BigBen</a>을 오픈소스화 했습니다. 질문이 있으면 저희에게 알려주십시오. 읽어주셔서 감사합니다!</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="February 24, 2021">February 24, 2021</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/tool_klevr-agent/" rel="bookmark">klevr_agent 빌드 후 Docker Image 만들기</a>
						</h1>
					</header>
					<div class="entry-content">
						<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ git clone git@github.com:jaehoonn/klevr.git
$ cd klevr
$ chmod +x ./build.sh
$ ./build.sh
$ cd cmd/klebr-agent/Dockerfile
$ docker build -t jaehoon/klevr-agent:0.2.6 .
$ docker login -u jaehoon -p <span style="color:#f92672">{</span>password<span style="color:#f92672">}</span>
$ docker push jaehoon/klevr-agent:0.2.6
</code></pre></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="February 19, 2021">February 19, 2021</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/git_delete-local-branch/" rel="bookmark">local branch 삭제</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>로컬에서 관리하고 있는 branch iss5783을 삭제합니다.</p>
<pre><code>$ git branch -d iss5783 
</code></pre><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="February 8, 2021">February 8, 2021</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/tool_etcd-setting/" rel="bookmark">etcd 설정</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>linux에서 etcd 클러스터 설정하기</p>
<p>How To Setup a etcd Cluster On Linux – Beginners Guide( <a href="https://devopscube.com/setup-etcd-cluster-linux/">https://devopscube.com/setup-etcd-cluster-linux/</a> ) 를 읽고해보는 요약입니다.</p>
<p>소개<br>
etcd는,</p>
<ul>
<li>key-value 저장소 중 하나 입니다.</li>
<li>raft 프로토콜을 사용합니다.</li>
<li>rest/grpc를 이용합니다.</li>
</ul>
<p>준비물</p>
<ul>
<li>3개의 linux 서버</li>
<li>각 서버의 호스트 이름</li>
<li>방화벽 개방(2380, 2379)</li>
</ul>
<p>설정<br>
etc-1: 10.128.0.2<br>
etc-2: 10.128.0.4<br>
etc-3: 10.128.0.3</p>
<p>으로 호스트 이름과 ip를 사용합니다. (ip는 각 상황에 맞춰서 사용합니다.)</p>
<p>각 서버 별로 1~6의 과정을 진행합니다.</p>
<ol>
<li>src 폴더로 이동합니다.</li>
</ol>
<pre><code>$ cd /usr/local/src
</code></pre><ol start="2">
<li>최신 버전의 etcd를 다운로드 합니다.</li>
</ol>
<pre><code>$ sudo wget &quot;https://github.com/coreos/etcd/releases/download/v3.3.9/etcd-v3.3.9-linux-amd64.tar.gz&quot;
</code></pre><ol start="3">
<li>tar를 풉니다.</li>
</ol>
<pre><code>$ sudo tar -xvf etcd-v3.3.9-linux-amd64.tar.gz
</code></pre><ol start="4">
<li>풀린 etcd 실행 파일들(etcd, etcctl)을 local/bin으로 이동합니다.</li>
</ol>
<pre><code>$ sudo mv etcd-v3.3.9-linux-amd64/etcd* /usr/local/bin/
</code></pre><ol start="5">
<li>etcd 폴더와 사용자 그리고 그룹을 만든다. etcd 사용자로 etcd 서비스를 실행합니다.</li>
</ol>
<pre><code>$ sudo mkdir -p /etc/etcd /var/lib/etcd
$ groupadd -f -g 1501 etcd
$ useradd -c &quot;etcd user&quot; -d /var/lib/etcd -s /bin/false -g etcd -u 1501 etcd
$ chown -R etcd:etcd /var/lib/etcd
</code></pre><ol start="6">
<li>root 사용자로 다음의 작업을 합니다.<br>
시스템 IP와 호스트 이름을 설정할 수 있는 두 개의 환경 변수를 설정합니다.</li>
</ol>
<pre><code>$ ETCD_HOST_IP=$(ip addr show eth0 | grep &quot;inet\b&quot; | awk '{print $2}' | cut -d/ -f1)
$ ETCD_NAME=$(hostname -s)
</code></pre><p>etcd용 systemd service 파일을 만듭니다.<br>
&ndash;listen-client-urls</p>
<p>note)
–name, –initial-advertise-peer-urls, –listen-peer-urls, –listen-client-urls는 각 서버마다 다릅니다. 
ETCD_NAME 및 ETCD_HOST_IP 변수가 자동으로 대체됩니다.</p>
<pre><code>cat &lt;&lt; EOF &gt; /lib/systemd/system/etcd.service
[Unit]
Description=etcd service
Documentation=https://github.com/coreos/etcd
 
[Service]
User=etcd
Type=notify
ExecStart=/usr/local/bin/etcd \\
 --name ${ETCD_NAME} \\
 --data-dir /var/lib/etcd \\
 --initial-advertise-peer-urls http://${ETCD_HOST_IP}:2380 \\
 --listen-peer-urls http://${ETCD_HOST_IP}:2380 \\
 --listen-client-urls http://${ETCD_HOST_IP}:2379,http://127.0.0.1:2379 \\
 --advertise-client-urls http://${ETCD_HOST_IP}:2379 \\
 --initial-cluster-token etcd-cluster-1 \\
 --initial-cluster etcd-1=http://10.142.0.2:2380,etcd-2=http://10.142.0.4:2380,etcd-3=http://10.142.0.3:2380 \\
 --initial-cluster-state new \\
 --heartbeat-interval 1000 \\
 --election-timeout 5000
Restart=on-failure
RestartSec=5
 
[Install]
WantedBy=multi-user.target
EOF
</code></pre><p>etcd 클러스터 구성하기</p>
<p>모든 서버에서 구성이 되고 난 후 etcd 서비스를 시작하고 활성화 합니다. 
첫번째 서버는 부트스트랩 노드로 동작하고 3개의 노드가 모두 시작되면 한 노드가 리더로 선정됩니다.</p>
<pre><code>$ systemctl daemon-reload
$ systemctl enable etcd
$ systemctl start etcd.service
$ systemctl status -l etcd.service
</code></pre><p>etcd 클러스터 상태 확인</p>
<p>etcdctl은 etcd 클러스터와 상호 작용하는 유틸리티 입니다. 이 유틸리티는 모든 노드의 &ldquo;/usr/local/bin&rdquo; 폴더에서 찾을 수 있습니다.
클러스터 노드중 하나에서 다음과 같이 확인 할 수 있습니다.</p>
<p>다음과 같이 클러스터의 상태를 확인 할 수 있습니다.</p>
<pre><code>$ etcdctl cluster-health
</code></pre><p>다음과 같이 하면 클러스터 멤버들의 상태와 리더의 상태를 확인 할 수 있습니다.</p>
<pre><code>$ etcdctl  member list
</code></pre><p>etcdctl은 기본으로 v2를 사용합니다. 그래서 v3을 사용하기 위해서는 환경 변수로 &ldquo;ETCDCTL_API=3&quot;을 명시하면 v3의 기능을 사용할 수 있습니다.<br>
아니면 다음과 같이 사용할 수 도 있습니다.</p>
<pre><code>$ ETCDCTL_API=3 etcdctl put name1 batman
$ ETCDCTL_API=3 etcdctl put name2 ironman
$ ETCDCTL_API=3 etcdctl put name3 superman
$ ETCDCTL_API=3 etcdctl put name4 spiderman
</code></pre><p>name3의 값을 얻기 위해서는 다음과 같이 합니다.</p>
<pre><code>$ ETCDCTL_API=3 etcdctl get name3
</code></pre><p>key들을 나열하거나 prefix를 사용해서 나열 할 수 있습니다.</p>
<pre><code>$ ETCDCTL_API=3 etcdctl get name1 name4 # lists range name1 to name 4
$ ETCDCTL_API=3 etcdctl get --prefix name # lists all keys with name prefix
</code></pre><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="February 1, 2021">February 1, 2021</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/git_remote-branch/" rel="bookmark">원격지의 branch 사용하기</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>github에 있는 branch를 로컬로 받아와서 작업하고 싶을때 할 수 있는 방법</p>
<p>원격지에 있는 branch 정보를 확인 할 수 있도록 업데이트 합니다.</p>
<pre><code>$ git remote update
</code></pre><p>원격지의 branch 확인</p>
<pre><code>$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/dev
  origin/tapping
  origin/master
  origin/9999
  origin/release
  upstream/dev
  upstream/master
  upstream/8888
  upstream/release
</code></pre><p>branch들 중에서 &ldquo;origin/9999&quot;를 갖고 오고 싶습니다.</p>
<pre><code>$ git checkout -t origin/9999
</code></pre><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="January 3, 2021">January 3, 2021</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/git_upstream/" rel="bookmark">upstream 설정</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>프로젝트 진행하는 과정에서 필요한 upstream 설정</p>
<p>해당 내용은 kubernetes의 GitHub Workflow 문서를 참고 했습니다.
( <a href="https://github.com/kubernetes/community/blob/master/contributors/guide/github-workflow.md">https://github.com/kubernetes/community/blob/master/contributors/guide/github-workflow.md</a> )</p>
<ol>
<li>
<p>프로젝트를 <a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a> 에서 내 github 계정으로 Fork 합니다.</p>
</li>
<li>
<p>Fork한 프로젝트를 내 로컬로 clone 합니다.</p>
</li>
</ol>
<pre><code>$ git clone git@github.com:{your-account}/kubernetes.git

// 작업 디렉토리로 이동
$ cd kubernetes 

// 현재 브랜치를 확인합니다.
$ git branch
* master
</code></pre><ol start="3">
<li>upstream으로 사용할 remote를 추가 합니다. 최초 프로젝트를 추가 합니다.</li>
</ol>
<pre><code>$ git remote add upstream git@github.com:kubernetes/kubernetes.git
</code></pre><ol start="4">
<li>remote를 확인해 보면 upstream이 생성되어 있습니다.</li>
</ol>
<pre><code>$ git remote -v
origin  git@github.com:{your-account}/kubernetes.git (fetch)
origin  git@github.com:{your-account}/kubernetes.git (push)
upstream        git@github.com:kubernetes/kubernetes.git (fetch)
upstream        git@github.com:kubernetes/kubernetes.git (push)
</code></pre><ol start="5">
<li>clone 받은 프로젝트에서는 upstream으로 직접 push하지 않도록 합니다.</li>
</ol>
<pre><code>$ git remote set-url --push upstream no_push
</code></pre><ol start="6">
<li>remote의 push가 no_push로 변경된 것 을 확인 합니다.</li>
</ol>
<pre><code>$ git remote -v
origin  git@github.com:{your-account}/kubernetes.git (fetch)
origin  git@github.com:{your-account}/kubernetes.git (push)
upstream        git@github.com:kubernetes/kubernetes.git (fetch)
upstream        no_push (push)
</code></pre><ol start="7">
<li>upstream의 변경된 내용을 fetch 받습니다.</li>
</ol>
<pre><code>$ git fetch upstream
remote: Enumerating objects: 20, done.
remote: Counting objects: 100% (20/20), done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 12 (delta 7), reused 8 (delta 5), pack-reused 0
Unpacking objects: 100% (12/12), 2.00 KiB | 48.00 KiB/s, done.
From github.com:kubernetes/kubernetes
 * [new branch]      259    -&gt; upstream/259
 * [new branch]      100    -&gt; upstream/100
 * [new branch]      master       -&gt; upstream/master
 * [new branch]      release      -&gt; upstream/release
</code></pre><ol start="8">
<li>fetch 받은 내용을 master 브랜치에 적용 합니다.</li>
</ol>
<pre><code>$ git checkout master

$ git rebase upstream/master
Successfully rebased and updated refs/heads/master.
</code></pre><ol start="9">
<li>master 브랜치에 upstream의 내용이 적용된 걸 확인 합니다.</li>
</ol>
<pre><code>$ git log
.....
</code></pre><ol start="10">
<li>fork 받은 리모트에 적용 합니다.</li>
</ol>
<pre><code>$ git push origin master
Total 0 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:{your-account}/kubernetes.git
   f89481d..922151e  master -&gt; master
</code></pre><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="May 19, 2020">May 19, 2020</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/container_kubectl_run/" rel="bookmark">Windows기반의 minikube로 로컬 환경의 image 사용해서 배포하기</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>실제 클러스터에 배포하기 전에 로컬 환경의 minikube를 이용해서 배포하고 테스트를 하기 위한 방법이 필요하면 다음과 같이 합니다.</p>
<p>minikube를 시작하고, minikube에 내장되어 있는 docker 데몬을 사용하도록 합니다. 이렇게 하면 호스트 머신의 Docker Registry를 사용하고 image도 호스트 머신에 생성해 놓은 것을 사용할 수 있습니다.<br>
(<a href="https://kubernetes.io/docs/setup/learning-environment/minikube/#use-local-images-by-re-using-the-docker-daemon">https://kubernetes.io/docs/setup/learning-environment/minikube/#use-local-images-by-re-using-the-docker-daemon</a>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; minikube docker-env
$Env:DOCKER_TLS_VERIFY <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1&#34;</span>
$Env:DOCKER_HOST <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;tcp://192.168.182.22:2376&#34;</span>
$Env:DOCKER_CERT_PATH <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;C:\Users\jaehoonn\.minikube\certs&#34;</span>
<span style="color:#75715e"># Run this command to configure your shell:</span>
<span style="color:#75715e"># &amp; minikube docker-env | Invoke-Expression</span>

PS&gt; minikube docker-env | Invoke-Expression
</code></pre></div><p>이렇게 하면, minikube vm 안에 존재하는 docker 데몬과 통신을 하게 됩니다.</p>
<p>이제 만들어 놓은 이미지를 실행합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn run sample-app --image<span style="color:#f92672">=</span>sample-app:latest --port<span style="color:#f92672">=</span><span style="color:#ae81ff">9000</span> --serviceaccount<span style="color:#f92672">=</span>jaehoonn-controller 
</code></pre></div><p>다음과 같이 배포가 된 것을 확인 할 수 있습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn get pods
NAME                             READY   STATUS              RESTARTS   AGE
sample-app-685bbd44c6-kgc4z      1/1     Running   <span style="color:#ae81ff">0</span>          5h24m
</code></pre></div><p>웹브라우저를 통해서 연결 상태를 확인하기 위해서 Service를 생성합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn expose deployment sample-app --type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;LoadBalancer&#34;</span>
</code></pre></div><p>생성된 Service를 확인하면, 다음과 같이 pending 상태이다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn get services
NAME             TYPE           CLUSTER-IP     EXTERNAL-IP   PORT<span style="color:#f92672">(</span>S<span style="color:#f92672">)</span>          AGE
sample-app       LoadBalancer   10.102.191.6   &lt;pending&gt;     8500:32416/TCP   11s
</code></pre></div><p>이제 minikube를 통해서 url을 생성합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; minikube -n jaehoonn service sample-app --url
* http://192.168.182.22:32416
</code></pre></div><p>필요한 테스트 작업을 완료하고 난 다음 해당 이미지를 중지하고자 할 때,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn delete pods/sample-app-685bbd44c6-kgc4z
pod <span style="color:#e6db74">&#34;sample-app-685bbd44c6-kgc4z&#34;</span> deleted
</code></pre></div><p>삭제 되었다는 메세지가 나오지만 실제로는 삭제 되지 않습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn get pod
NAME                             READY   STATUS              RESTARTS   AGE
sample-app-685bbd44c6-kgc4z      1/1     Running             <span style="color:#ae81ff">0</span>          5h24m
</code></pre></div><p>모든 리소스를 조회해보면 다음과 같습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn get all
NAME                                 READY   STATUS              RESTARTS   AGE
pod/sample-app-685bbd44c6-fxl8f      1/1     Running             <span style="color:#ae81ff">0</span>          7m3s




NAME                            READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/sample-app      1/1     <span style="color:#ae81ff">1</span>            <span style="color:#ae81ff">0</span>           5h36m

NAME                                       DESIRED   CURRENT   READY   AGE
replicaset.apps/sample-app-685bbd44c6      <span style="color:#ae81ff">1</span>         <span style="color:#ae81ff">1</span>         <span style="color:#ae81ff">0</span>       5h36m
</code></pre></div><p>여기에서 deployment를 삭제하면 관련된 모든 리소스가 삭제됩니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn delete deployment/sample-app
deployment.extensions <span style="color:#e6db74">&#34;discovery&#34;</span> deleted
</code></pre></div><p>다시 모든 리소스를 조회해보면 다음과 같이 모두 삭제된 걸 확인할 수 있습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS&gt; kubectl -n jaehoonn get all

No resources found.
</code></pre></div><p>이 작업으로 Service까지 삭제 되지는 않습니다.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="May 18, 2020">May 18, 2020</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/go_crosscompile_on_windows/" rel="bookmark">Powershell에서 할 수 있는 Linux를 위한 빌드</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>Windows 환경에서 개발 후 Linux 환경으로 배포하기 위해서 Linux용 바이너리로 빌드가 필요할 때가 있습니다.<br>
다음의 방법으로 빌드 할 수 있습니다.</p>
<p>Powershell에서 빌드하기 위한 방법은 아래와 같습니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">PS D:<span style="color:#ae81ff">\w</span>s<span style="color:#ae81ff">\s</span>rc<span style="color:#ae81ff">\s</span>ample&gt; $env:GOOS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;linux&#34;</span>; go build
</code></pre></div><p>빌드 이후에는 필요에 따라서 &ldquo;GOOS&quot;를 다시 &ldquo;windows&quot;로 돌려 놓습니다.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="April 10, 2020">April 10, 2020</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/container_private-container-registry/" rel="bookmark">Kubernetes에서 Private Container Registry 사용</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>Kubernetes에 배포하기 위해서 Container Registry(Private)을 사용하려면, 별도의 secret을 등록해야 합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ kubectl create secret docker-registry <span style="color:#f92672">{</span>secret<span style="color:#f92672">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--docker-server<span style="color:#f92672">={</span>registryserver<span style="color:#f92672">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--docker-username<span style="color:#f92672">={</span>name<span style="color:#f92672">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--docker-password<span style="color:#f92672">={</span>password<span style="color:#f92672">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--docker-email<span style="color:#f92672">={</span>email<span style="color:#f92672">}</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>--namespace<span style="color:#f92672">={</span>namespace<span style="color:#f92672">}</span>
</code></pre></div><p>namespace는 지정하지 않으면 default로 지정됩니다.</p>
<p>그리고 Container Registry로 부터 image를 받아서 사용하기 위한 yaml 파일에 다음과 같이 추가합니다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">apiVersion: v1
kind: Pod
metadata:
  name: private-reg
spec:
  containers:
  - name: private-reg-container
    image: regcred/projectaa/private-reg:latest
  imagePullSecrets:
  - name: regcred
</code></pre></div><p>&ldquo;imagePullSecrets&rdquo; 항목을 추가하고 containers.image에서 iamgePullSecretes.name을 base로 사용합니다.</p>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
				<article class="post">
					<header class="entry-header">
						<div class="entry-meta">
               <span class="posted-on">
                  <time class="entry-date published" datetime="April 8, 2020">April 8, 2020</time>
               </span>
						</div>
						<h1 class="entry-title">
						  <a href="https://shrinklabs.com/post/container_docker-error/" rel="bookmark">docker 설치 후 에러</a>
						</h1>
					</header>
					<div class="entry-content">
						<p>docker 설치 후 &ldquo;Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?&rdquo; 가 발생</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$sudo systemctl status docker

$sudo systemctl start docker

$sudo systemctl enable docker
</code></pre></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-8444244371421612"
     data-ad-slot="6693872766"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

					</div>
				</article>
        
			</div>
		</div>

		<center class="">
			<ul class="pagination">
        
<ul class="pagination">
  <li class="page-item">
    <a href="/post/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/post/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/2/">2</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/3/">3</a>
  </li>
  <li class="page-item disabled">
    <span aria-hidden="true">&nbsp;&hellip;&nbsp;</span>
  </li>
  <li class="page-item">
    <a class="page-link" href="/post/page/6/">6</a>
  </li>
  <li class="page-item">
    <a href="/post/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/post/page/6/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


			</ul>
		</center>
	</div>	

</main>

    
    
      <footer id="footer">
	<div class="container">
		<div class="row">
			

			
			<div class="col-md-3 widget">
				<h3 class="widget-title">Follow me</h3>
				<div class="widget-body">
					<p class="follow-me-icons">
            
							
								<a href="https://www.facebook.com/jaehoon" target="_blank"><i class="fab fa-facebook-square fa-1x"></i></a>
							
            
							
								<a href="https://twitter.com/jaehoonn_" target="_blank"><i class="fab fa-twitter-square fa-1x"></i></a>
							
            
							
								<a href="https://github.com/jaehoonn" target="_blank"><i class="fab fa-github fa-1x"></i></a>
							
            
							
								<a href="mailto:jaehoon@shrinklabs.com" target="_blank"><i class="fas fa-envelope-square fa-1x"></i></a>
							
            
					</p>
				</div>
			</div>
			

			

			

		</div> 
	</div>
</footer>

<footer id="underfooter">
	<div class="container">
		<div class="row">

			<div class="col-md-6 widget">
				<div class="widget-body">
					<p></p>
				</div>
			</div>

			<div class="col-md-6 widget">
				<div class="widget-body">
					<p class="text-right">
						Copyright &copy; 2021, <br>
						Design: <a href="http://www.gettemplate.com" rel="designer">Initio by GetTemplate</a> - 
						Powered by: <a href="https://gohugo.io/" rel="poweredby">Hugo</a>
					</p>
				</div>
			</div>

		</div> 
	</div>
</footer>




<script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>




<script src="https://shrinklabs.com/js/bundle.min.f4a965ad0a8118e32f8f0f158ff3aadbacf700934c22286a1a5b245105e9006da73a873b001a160db22498909c1df14d1f835dba5ad76f80b32b0234182b2a58.js" integrity="sha512-9KllrQqBGOMvjw8Vj/Oq26z3AJNMIihqGlskUQXpAG2nOoc7ABoWDbIkmJCcHfFNH4NdulrXb4CzKwI0GCsqWA=="></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-4LRCTZDF74', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>

    
  </body>
  
</html>