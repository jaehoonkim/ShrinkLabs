<!DOCTYPE html>
<html lang="en">
    <head>
		
		
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>Posts &middot; ShrinkLabs</title>

		
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="/post/index.xml" rel="alternate" type="application/rss+xml" title="ShrinkLabs" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">ShrinkLabs</h2>
				</a>
				<ul>
    
    
        <li>
            <a href="/about/">
                
                <span>about</span>
                
            </a>
        </li>
    
</ul>
			</div>
		</nav>

        

<main>
	<div class="catalogue">
		
			<a href="https://shrinklabs.com/post/leader_election_using_consul_and_golang/" class="catalogue-item">
    <div>
        <time datetime="2021-06-27 21:33:58 &#43;0900 KST" class="catalogue-time">June 27, 2021</time>
        <h1 class="catalogue-title">Consul과 Golang을 사용한 리더 선출</h1>
        <div class="catalogue-line"></div>

        <p>
            이 글은 원글(Leader Election using Consul and Golang)의 저작자 Sunny Aggrawal씨의 허락을 받고 번역한 글 입니다.
 분산 컴퓨팅에서 리더 선택은 단일 노드를 여러 노드에 분산되는 일부 작업의 주관자로 지정하는 프로세스입니다. 처음에는 모든 네트워크 노드가 작업의 &ldquo;리더&rdquo; 역할을 할 노드를 알지 못합니다. 리더 선택 알고리즘이 실행된 후, 네트워크의 각 노드는 특정 고유 노드를 작업 리더로 인식하고 다른 노드는 팔로워 노드 역할을 합니다.
리더 - 클러스터의 노드가 특수 작업을 수행하도록 지정되었습니다. 이러한 특수 작업에는 작업 할당 기능, 데이터 수정 기능 또는 시스템의 모든 요청을 처리하는 책임도 포함될 수 있습니다.
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/scheduler_an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler/" class="catalogue-item">
    <div>
        <time datetime="2021-06-16 00:17:00 &#43;0900 KST" class="catalogue-time">June 16, 2021</time>
        <h1 class="catalogue-title">내결함성 수평 확장성이 있는 분산형 이벤트 스케줄러 설계 방법</h1>
        <div class="catalogue-line"></div>

        <p>
            이 글은 원글(An Approach to Designing a Distributed, Fault-Tolerant, Horizontally Scalable Event Scheduler)의 저작자 Sandeep Malik씨의 허락을 받고 번역한 글 입니다.
 소개 시간 기반 이벤트 스케줄러를 설계하는 것은 항상 흥미로운 문제입니다. 규모에 맞게 작업을 수행하는 것은 훨씬 더 어려운 일입니다. 먼저 시간 기반 이벤트 스케줄러가 무엇을 의미하는지 정의해 보겠습니다.
시간 기반 이벤트 스케줄러는 서비스가 나중에 (future) 처리해야 하는 요청을 예약하는 데 사용할 수 있는 시스템입니다. 서비스는 스케줄러에 이벤트(event)를 등록하고 현재 요청의 처리를 일시 중단합니다.
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/tool_klevr-agent/" class="catalogue-item">
    <div>
        <time datetime="2021-02-24 03:08:00 &#43;0900 KST" class="catalogue-time">February 24, 2021</time>
        <h1 class="catalogue-title">klevr_agent 빌드 후 Docker Image 만들기</h1>
        <div class="catalogue-line"></div>

        <p>
            $ git clone git@github.com:jaehoonn/klevr.git $ cd klevr $ chmod +x ./build.sh $ ./build.sh $ cd cmd/klebr-agent/Dockerfile $ docker build -t jaehoon/klevr-agent:0.2.6 . $ docker login -u jaehoon -p {password} $ docker push jaehoon/klevr-agent:0.2.6 (adsbygoogle = window.adsbygoogle || []).push({}); 
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/git_delete-local-branch/" class="catalogue-item">
    <div>
        <time datetime="2021-02-19 07:17:00 &#43;0900 KST" class="catalogue-time">February 19, 2021</time>
        <h1 class="catalogue-title">local branch 삭제</h1>
        <div class="catalogue-line"></div>

        <p>
            로컬에서 관리하고 있는 branch iss5783을 삭제합니다.
$ git branch -d iss5783 (adsbygoogle = window.adsbygoogle || []).push({}); 
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/tool_etcd-setting/" class="catalogue-item">
    <div>
        <time datetime="2021-02-08 02:20:00 &#43;0900 KST" class="catalogue-time">February 8, 2021</time>
        <h1 class="catalogue-title">etcd 설정</h1>
        <div class="catalogue-line"></div>

        <p>
            linux에서 etcd 클러스터 설정하기
How To Setup a etcd Cluster On Linux – Beginners Guide( https://devopscube.com/setup-etcd-cluster-linux/ ) 를 읽고해보는 요약입니다.
소개
etcd는,
 key-value 저장소 중 하나 입니다. raft 프로토콜을 사용합니다. rest/grpc를 이용합니다.  준비물
 3개의 linux 서버 각 서버의 호스트 이름 방화벽 개방(2380, 2379)  설정
etc-1: 10.128.0.2
etc-2: 10.128.0.4
etc-3: 10.128.0.3
으로 호스트 이름과 ip를 사용합니다. (ip는 각 상황에 맞춰서 사용합니다.)
각 서버 별로 1~6의 과정을 진행합니다.
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/git_remote-branch/" class="catalogue-item">
    <div>
        <time datetime="2021-02-01 07:17:00 &#43;0900 KST" class="catalogue-time">February 1, 2021</time>
        <h1 class="catalogue-title">원격지의 branch 사용하기</h1>
        <div class="catalogue-line"></div>

        <p>
            github에 있는 branch를 로컬로 받아와서 작업하고 싶을때 할 수 있는 방법
원격지에 있는 branch 정보를 확인 할 수 있도록 업데이트 합니다.
$ git remote update원격지의 branch 확인
$ git branch -rorigin/HEAD -&gt; origin/masterorigin/devorigin/tappingorigin/masterorigin/9999origin/releaseupstream/devupstream/masterupstream/8888upstream/releasebranch들 중에서 &ldquo;origin/9999&quot;를 갖고 오고 싶습니다.
$ git checkout -t origin/9999(adsbygoogle = window.adsbygoogle || []).push({}); 
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/git_upstream/" class="catalogue-item">
    <div>
        <time datetime="2021-01-03 03:29:09 &#43;0900 KST" class="catalogue-time">January 3, 2021</time>
        <h1 class="catalogue-title">upstream 설정</h1>
        <div class="catalogue-line"></div>

        <p>
            프로젝트 진행하는 과정에서 필요한 upstream 설정
해당 내용은 kubernetes의 GitHub Workflow 문서를 참고 했습니다. ( https://github.com/kubernetes/community/blob/master/contributors/guide/github-workflow.md )
  프로젝트를 https://github.com/kubernetes/kubernetes 에서 내 github 계정으로 Fork 합니다.
  Fork한 프로젝트를 내 로컬로 clone 합니다.
  $ git clone git@github.com:{your-account}/kubernetes.git// 작업 디렉토리로 이동$ cd kubernetes // 현재 브랜치를 확인합니다.$ git branch* masterupstream으로 사용할 remote를 추가 합니다. 최초 프로젝트를 추가 합니다.  $ git remote add upstream git@github.
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/container_kubectl_run/" class="catalogue-item">
    <div>
        <time datetime="2020-05-19 01:05:57 &#43;0900 KST" class="catalogue-time">May 19, 2020</time>
        <h1 class="catalogue-title">Windows기반의 minikube로 로컬 환경의 image 사용해서 배포하기</h1>
        <div class="catalogue-line"></div>

        <p>
            실제 클러스터에 배포하기 전에 로컬 환경의 minikube를 이용해서 배포하고 테스트를 하기 위한 방법이 필요하면 다음과 같이 합니다.
minikube를 시작하고, minikube에 내장되어 있는 docker 데몬을 사용하도록 합니다. 이렇게 하면 호스트 머신의 Docker Registry를 사용하고 image도 호스트 머신에 생성해 놓은 것을 사용할 수 있습니다.
(https://kubernetes.io/docs/setup/learning-environment/minikube/#use-local-images-by-re-using-the-docker-daemon)
PS&gt; minikube docker-env $Env:DOCKER_TLS_VERIFY = &#34;1&#34; $Env:DOCKER_HOST = &#34;tcp://192.168.182.22:2376&#34; $Env:DOCKER_CERT_PATH = &#34;C:\Users\jaehoonn\.minikube\certs&#34; # Run this command to configure your shell: # &amp; minikube docker-env | Invoke-Expression PS&gt; minikube docker-env | Invoke-Expression 이렇게 하면, minikube vm 안에 존재하는 docker 데몬과 통신을 하게 됩니다.
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/go_crosscompile_on_windows/" class="catalogue-item">
    <div>
        <time datetime="2020-05-18 10:52:23 &#43;0900 KST" class="catalogue-time">May 18, 2020</time>
        <h1 class="catalogue-title">Powershell에서 할 수 있는 Linux를 위한 빌드</h1>
        <div class="catalogue-line"></div>

        <p>
            Windows 환경에서 개발 후 Linux 환경으로 배포하기 위해서 Linux용 바이너리로 빌드가 필요할 때가 있습니다.
다음의 방법으로 빌드 할 수 있습니다.
Powershell에서 빌드하기 위한 방법은 아래와 같습니다.
PS D:\ws\src\sample&gt; $env:GOOS=&#34;linux&#34;; go build 빌드 이후에는 필요에 따라서 &ldquo;GOOS&quot;를 다시 &ldquo;windows&quot;로 돌려 놓습니다.
(adsbygoogle = window.adsbygoogle || []).push({}); 
        </p>
    </div>
</a>

		
			<a href="https://shrinklabs.com/post/container_private-container-registry/" class="catalogue-item">
    <div>
        <time datetime="2020-04-10 16:31:48 &#43;0900 KST" class="catalogue-time">April 10, 2020</time>
        <h1 class="catalogue-title">Kubernetes에서 Private Container Registry 사용</h1>
        <div class="catalogue-line"></div>

        <p>
            Kubernetes에 배포하기 위해서 Container Registry(Private)을 사용하려면, 별도의 secret을 등록해야 합니다.
$ kubectl create secret docker-registry {secret} \ --docker-server={registryserver} \ --docker-username={name} \ --docker-password={password} \ --docker-email={email} \ --namespace={namespace} namespace는 지정하지 않으면 default로 지정됩니다.
그리고 Container Registry로 부터 image를 받아서 사용하기 위한 yaml 파일에 다음과 같이 추가합니다.
apiVersion: v1 kind: Pod metadata: name: private-reg spec: containers: - name: private-reg-container image: regcred/projectaa/private-reg:latest imagePullSecrets: - name: regcred &ldquo;imagePullSecrets&rdquo; 항목을 추가하고 containers.image에서 iamgePullSecretes.name을 base로 사용합니다.
(adsbygoogle = window.
        </p>
    </div>
</a>

		
	</div>
	
	<div class="pagination">
		
		
			<a href="/post/page/2/" class="right arrow">&#8594;</a>
		
	
		<span>1</span>
	</div>
</main>


        		<footer>
			
			<span>
			&copy; <time datetime="2021-08-19 10:58:05.1985988 &#43;0900 KST m=&#43;0.293371001">2021</time> . Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
